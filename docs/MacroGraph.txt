Directory Structure:

└── ./
    ├── apps
    │   └── server
    │       ├── src
    │       │   ├── auto-imports.d.ts
    │       │   ├── dev-server.ts
    │       │   ├── entry-client.tsx
    │       │   ├── entry-server.tsx
    │       │   ├── global.d.ts
    │       │   ├── prod-server.ts
    │       │   └── vite-env.d.ts
    │       └── vite.config.ts
    └── packages
        ├── domain
        │   ├── src
        │   │   ├── Graph.ts
        │   │   ├── index.ts
        │   │   ├── io.ts
        │   │   ├── Node.ts
        │   │   ├── package.ts
        │   │   ├── runtime.ts
        │   │   ├── schema.ts
        │   │   └── SubscribableCache.ts
        │   ├── package.json
        │   └── tsconfig.json
        ├── http-client
        │   ├── src
        │   │   └── index.ts
        │   ├── package.json
        │   └── tsconfig.json
        ├── server-backend
        │   ├── src
        │   │   ├── ClientAuth
        │   │   │   └── rpc.ts
        │   │   ├── CloudApi
        │   │   │   ├── ApiClient.ts
        │   │   │   ├── AuthState.ts
        │   │   │   ├── CredentialsCache.ts
        │   │   │   └── rpc.ts
        │   │   ├── Project
        │   │   │   ├── Actions.ts
        │   │   │   ├── NodeIdCounter.ts
        │   │   │   ├── Packages.ts
        │   │   │   └── rpc.ts
        │   │   ├── global.d.ts
        │   │   ├── Graph.ts
        │   │   ├── index.ts
        │   │   ├── Node.ts
        │   │   ├── Presence.ts
        │   │   ├── project-data.ts
        │   │   └── Realtime.ts
        │   └── package.json
        ├── server-domain
        │   ├── src
        │   │   ├── ClientAuth.ts
        │   │   ├── CloudAuth.ts
        │   │   ├── errors.ts
        │   │   ├── event.ts
        │   │   ├── Graph.ts
        │   │   ├── index.ts
        │   │   ├── IO.ts
        │   │   ├── Node.ts
        │   │   ├── Presence.ts
        │   │   ├── Project.ts
        │   │   ├── Realtime.ts
        │   │   └── util.ts
        │   ├── package.json
        │   └── tsconfig.json
        └── server-frontend
            ├── src
            │   ├── Graph
            │   │   ├── Context.ts
            │   │   ├── ContextMenu.tsx
            │   │   ├── Graph.tsx
            │   │   └── PresencePointer.tsx
            │   ├── Packages
            │   │   ├── Context.tsx
            │   │   └── PackagesSettings.ts
            │   ├── Presence
            │   │   ├── ClientListDropdown.tsx
            │   │   └── Context.tsx
            │   ├── Project
            │   │   ├── Actions.ts
            │   │   ├── Realtime.ts
            │   │   ├── Rpc.ts
            │   │   └── State.ts
            │   ├── routes
            │   │   ├── settings
            │   │   │   └── account.tsx
            │   │   ├── index.tsx
            │   │   ├── packages.[package].tsx
            │   │   ├── packages.tsx
            │   │   ├── Routes.tsx
            │   │   └── settings.tsx
            │   ├── AppRuntime.tsx
            │   ├── Auth.ts
            │   ├── Avatar.tsx
            │   ├── global.d.ts
            │   ├── Header.tsx
            │   ├── index.tsx
            │   ├── Layout.tsx
            │   ├── Node.tsx
            │   ├── Realtime.ts
            │   ├── style.css
            │   └── utils.ts
            ├── package.json
            └── tsconfig.json



---
File: /apps/server/src/auto-imports.d.ts
---

/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// noinspection JSUnusedGlobalSymbols
// Generated by unplugin-auto-import
// biome-ignore lint: disable
export {}
declare global {
  const IconLineMdChevronDown: typeof import('~icons/line-md/chevron-down.jsx')['default']
  const IconLineMdChevronSmallDown: typeof import('~icons/line-md/chevron-small-down.jsx')['default']
  const IconLucideChevronDown: typeof import('~icons/lucide/chevron-down.jsx')['default']
  const IconMaterialSymbolsDeleteOutline: typeof import('~icons/material-symbols/delete-outline.jsx')['default']
}



---
File: /apps/server/src/dev-server.ts
---

import { createServer } from "node:http";
import { HttpServer } from "@effect/platform";
import { NodeHttpServer, NodeRuntime } from "@effect/platform-node";
import { DepsLive } from "@macrograph/server-backend";
import { Fiber, Layer, Option } from "effect";
import * as Effect from "effect/Effect";

import { ServerEntry } from "./entry-server";

const HMRAwareNodeHttpServerLayer = NodeHttpServer.layer(
	() => {
		const server = createServer();

		const fiber = Option.getOrThrow(Fiber.getCurrentFiber());

		if (import.meta.hot) {
			import.meta.hot.accept(() => {
				Fiber.interrupt(fiber).pipe(Effect.runPromise);
				server.closeAllConnections();
				server.close();
			});
		}

		return server;
	},
	{ port: 5678, host: "0.0.0.0" },
);

const program = Effect.gen(function* () {
	const server = yield* ServerEntry;

	return yield* Layer.launch(
		server.pipe(HttpServer.serve(), Layer.provide(HMRAwareNodeHttpServerLayer)),
	);
});

program.pipe(Effect.provide(DepsLive), Effect.scoped, NodeRuntime.runMain);



---
File: /apps/server/src/entry-client.tsx
---

import { PackagesSettings, UI, runtime } from "@macrograph/server-frontend";
import { Effect, Layer } from "effect";

const ClientLive = Layer.unwrapEffect(
	Effect.gen(function* () {
		const packageSettings = yield* Effect.promise(
			() => import("@macrograph/base-packages/Settings"),
		);

		yield* Effect.all(
			Object.entries(packageSettings.default).map(([id, getPkg]) =>
				Effect.gen(function* () {
					const pkg = yield* Effect.promise(getPkg);

					yield* PackagesSettings.addPackage(id, pkg);
				}),
			),
			{ concurrency: 3 },
		);

		console.log(yield* PackagesSettings.listPackages());

		return UI.Default;
	}),
);

runtime.runPromise(Layer.launch(ClientLive).pipe(Effect.scoped));



---
File: /apps/server/src/entry-server.tsx
---

import * as Packages from "@macrograph/base-packages";
import { ProjectActions, ServerLive } from "@macrograph/server-backend";
import { Effect } from "effect";

const loadPackages = Effect.gen(function* () {
	const projectActions = yield* ProjectActions;

	yield* projectActions.addPackage("util", Packages.util).pipe(Effect.orDie);
	yield* projectActions
		.addPackage("twitch", Packages.twitch)
		.pipe(Effect.orDie);
	yield* projectActions.addPackage("obs", Packages.obs).pipe(Effect.orDie);
});

export const ServerEntry = Effect.zipRight(loadPackages, ServerLive);



---
File: /apps/server/src/global.d.ts
---

declare type DeepWriteable<T> = T extends import("effect").Brand.Brand<any>
	? T
	: T extends object
		? { -readonly [P in keyof T]: DeepWriteable<T[P]> }
		: T;



---
File: /apps/server/src/prod-server.ts
---

import { createServer } from "node:http";
import {
	HttpMiddleware,
	HttpRouter,
	HttpServer,
	HttpServerRequest,
	HttpServerResponse,
} from "@effect/platform";
import { NodeHttpServer, NodeRuntime } from "@effect/platform-node";
import { DepsLive } from "@macrograph/server-backend";
import { Effect, Layer } from "effect";

import { ServerEntry } from "./entry-server";

Layer.unwrapEffect(
	Effect.gen(function* () {
		return HttpRouter.empty.pipe(
			HttpRouter.all(
				"*",
				Effect.sync(() => HttpServerResponse.empty({ status: 494 })),
			),
			HttpRouter.use(
				HttpMiddleware.make(() =>
					Effect.gen(function* () {
						const httpServerRequest =
							yield* HttpServerRequest.HttpServerRequest;
						let { url } = httpServerRequest;
						if (url === "/") url = "/index.html";

						let response = yield* HttpServerResponse.file(`dist/client${url}`);

						if (url.startsWith("/assets"))
							response = response.pipe(
								HttpServerResponse.setHeader(
									"cache-control",
									"public,immutable,max-age=31536000",
								),
							);

						return response;
					}),
				),
			),
			HttpRouter.mountApp("/api", yield* ServerEntry),
			HttpServer.serve(),
		);
	}),
).pipe(
	Layer.provide(NodeHttpServer.layer(createServer, { port: 23456 })),
	Layer.launch,
	Effect.provide(DepsLive),
	Effect.scoped,
	NodeRuntime.runMain,
);



---
File: /apps/server/src/vite-env.d.ts
---

/// <reference types="vite/client" />

declare module "macrograph:package-settings" {
	export default {} as Record<string, () => Promise<PackageSettingsModule>>;
}

declare interface PackageSettingsModule {
	default: import("solid-js").Component<
		import("./package-settings-utils").SettingsProps<any, any>
	>;
	Rpcs: import("@effect/rpc/RpcGroup").RpcGroup<any>;
}



---
File: /apps/server/vite.config.ts
---

import basePackagesPlugin from "@macrograph/base-packages/vite";
import UnoCSS from "unocss/vite";
import AutoImport from "unplugin-auto-import/vite";
import IconsResolver from "unplugin-icons/resolver";
import Icons from "unplugin-icons/vite";
import { defineConfig, isRunnableDevEnvironment } from "vite";
import solid from "vite-plugin-solid";

const serverEnvironmentEntry = "./src/prod-server.ts";

export default defineConfig({
	server: {
		allowedHosts: true,
		proxy: {
			"/api": {
				ws: true,
				changeOrigin: true,
				target: "http://localhost:5678",
				rewrite: (path) => path.replace(/^\/api/, ""),
			},
		},
	},
	environments: {
		client: {
			consumer: "client",
			build: {
				ssr: false,
				rollupOptions: {
					output: {
						dir: "./dist/client",
					},
				},
			},
		},
		server: {
			consumer: "server",
			build: {
				ssr: true,
				// we don't write to the file system as the below 'capture-output' plugin will
				// capture the output and write it to the virtual file system
				write: true,
				manifest: true,
				copyPublicDir: false,
				rollupOptions: {
					input: serverEnvironmentEntry,
					output: {
						dir: "./dist/server",
						entryFileNames: "index.mjs",
					},
				},
				commonjsOptions: {
					include: [/node_modules/],
				},
			},
		},
	},
	builder: {
		sharedPlugins: true,
		async buildApp(builder) {
			const clientEnv = builder.environments["client"];
			const serverEnv = builder.environments["server"];

			if (!clientEnv) throw new Error("Client environment not found");
			if (!serverEnv) throw new Error("SSR environment not found");

			await builder.build(clientEnv);
			await builder.build(serverEnv);
		},
	},
	plugins: [
		{
			name: "macrograph-dev-server",
			enforce: "pre",
			configureServer: async (server) => {
				const serverEnv = server.environments.server;
				if (!serverEnv) throw new Error("Server environment not found");
				if (!isRunnableDevEnvironment(serverEnv))
					throw new Error("Server environment is not runnable");

				await serverEnv.runner.import("./src/dev-server").catch((e) => {
					console.error(e);
				});
			},
		},
		UnoCSS(),
		AutoImport({
			resolvers: [
				IconsResolver({
					prefix: "Icon",
					extension: "jsx",
				}),
			],
			dts: "./src/auto-imports.d.ts",
		}),
		Icons({ compiler: "solid", autoInstall: true }),
		basePackagesPlugin,
		solid(),
	],
});



---
File: /packages/domain/src/Graph.ts
---

import { Schema } from "effect";

export const Id = Schema.Int.pipe(Schema.brand("Graph ID"));
export type Id = (typeof Id)["Type"];

export class NotFound extends Schema.TaggedError<NotFound>()(
	"@macrograph/domain/Graph/NotFound",
	{ graphId: Id },
) {}



---
File: /packages/domain/src/index.ts
---

export * from "./io";
export * from "./schema";
export * as Node from "./Node";
export * as Graph from "./Graph";
export * from "./package";
export * from "./runtime";
export * from "./SubscribableCache";



---
File: /packages/domain/src/io.ts
---

import type { Brand } from "effect";

export type IOId = string & Brand.Brand<"IOId">;

export class ExecInputRef {
	constructor(public id: string) {}
}

export class ExecOutputRef {
	constructor(public id: IOId) {}
}

export class DataInputRef<T> {
	constructor(
		public id: IOId,
		public type: T,
	) {}
}

export class DataOutputRef<T> {
	constructor(
		public id: string,
		public type: T,
	) {}
}



---
File: /packages/domain/src/Node.ts
---

import { Schema } from "effect";

export const Variant = Schema.Literal("exec", "base", "pure", "event");
export type Variant = Schema.Schema.Type<typeof Variant>;

export const Id = Schema.Int.pipe(Schema.brand("Node ID"));
export type Id = Schema.Schema.Type<typeof Id>;

export const IORef = Schema.Struct({
	nodeId: Id,
	ioId: Schema.String,
});
export type IORef = Schema.Schema.Type<typeof IORef>;



---
File: /packages/domain/src/package.ts
---

import type { Rpc, RpcGroup } from "@effect/rpc";
import type { CREDENTIAL } from "@macrograph/web-api";
import { Context, Data, Effect, type Layer, Schema } from "effect";

import type { NodeRuntime } from "./runtime";
import type { NodeSchema, SchemaDefinition } from "./schema";

export namespace PackageEngine {
	type Requirements = PackageEngineContext | NodeRuntime;

	export class PackageEngineContext extends Context.Tag("PackageEngineContext")<
		PackageEngineContext,
		{ packageId: string }
	>() {}

	export type PackageEngine = Effect.Effect<void, never, Requirements>;
}

export class DuplicateSchemaId extends Data.TaggedError("DuplicateSchemaId") {}

export class ForceRetryError extends Data.TaggedError("ForceRetryError") {}

export type PackageBuildReturn<
	TRpcs extends Rpc.Any,
	TState extends Schema.Schema<any>,
> = {
	engine: PackageEngine.PackageEngine;
} & (
	| {
			rpc: {
				group: RpcGroup.RpcGroup<TRpcs>;
				layer: Layer.Layer<Rpc.ToHandler<TRpcs>>;
			};
			state: {
				schema: TState;
				get: Effect.Effect<TState["Encoded"]>;
			};
	  }
	| { rpc?: undefined; state?: undefined }
);

export class CredentialsFetchFailed extends Schema.TaggedError<CredentialsFetchFailed>()(
	"CredentialsFetchFailed",
	{ message: Schema.String },
) {}

export interface PackageContext<TEvents> {
	dirtyState: Effect.Effect<void>;
	credentials: Effect.Effect<
		ReadonlyArray<(typeof CREDENTIAL)["Encoded"]>,
		CredentialsFetchFailed
	>;
	refreshCredential(id: string): Effect.Effect<never, ForceRetryError>;
	emitEvent(event: TEvents): Effect.Effect<void>;
}
export type PackageDefinition<
	TRpcs extends Rpc.Any,
	TState extends Schema.Schema<any>,
	TEvents,
> = (
	pkg: PackageBuilder,
	ctx: PackageContext<TEvents>,
) => Effect.Effect<void | PackageBuildReturn<TRpcs, TState>, DuplicateSchemaId>;

export function definePackage<
	TRpcs extends Rpc.Any,
	TState extends Schema.Schema<any>,
	TEvents,
>(cb: PackageDefinition<TRpcs, TState, TEvents>) {
	return cb;
}

export class PackageBuilder {
	private schemas = new Map<string, NodeSchema<any, any, any>>();

	constructor(public readonly id: string) {}

	schema = <TIO>(id: string, schema: SchemaDefinition<TIO, any, any>) => {
		const self = this;
		// return Effect.gen(function* () {
		//   if (self.schemas.has(id)) return yield* new DuplicateSchemaId();

		self.schemas.set(id, {
			...schema,
			run: Effect.fn(schema.run as any),
		} as NodeSchema<TIO, any, any>);
		// });
	};

	/** @internal */
	toPackage(ret?: PackageBuildReturn<any, any>): Package {
		return new Package(this.id, this.schemas, ret?.engine);
	}
}

export class Package {
	constructor(
		public readonly id: string,
		public readonly schemas: Map<string, NodeSchema<any, any, any>>,
		public engine?: PackageEngine.PackageEngine,
	) {}
}



---
File: /packages/domain/src/runtime.ts
---

import { Context, Data, type Effect, Schema } from "effect";
import type { NoSuchElementException } from "effect/Cause";

import type { Id as NodeId } from "./Node";
import type { DataInputRef, DataOutputRef } from "./io";

export class NotComputationNode extends Data.TaggedError(
	"@macrograph/domain/NotComputationNode",
) {}

export class NotEventNode extends Data.TaggedError(
	"@macrograph/domain/NotEventNode",
) {}

export class SchemaNotFound extends Schema.TaggedError<SchemaNotFound>()(
	"@macrograph/domain/SchemaNotFound",
	{
		pkgId: Schema.String,
		schemaId: Schema.String,
	},
) {}

export class NodeRuntime extends Context.Tag("NodeRuntime")<
	NodeRuntime,
	{
		emitEvent: (
			packageId: string,
			eventId: string,
			data?: any,
		) => Effect.Effect<void, NoSuchElementException>;
	}
>() {}

export type SchemaRunGeneratorEffect = Effect.Effect<
	any,
	NoSuchElementException | NotComputationNode,
	RunFunctionAvailableRequirements
>;

export class Logger extends Context.Tag("Logger")<
	Logger,
	{ print: (value: string) => Effect.Effect<void> }
>() {}

export type RunFunctionAvailableRequirements =
	// | Logger
	ExecutionContext | NodeExecutionContext;

export class ExecutionContext extends Context.Tag("ExecutionContext")<
	ExecutionContext,
	{
		traceId: string;
		getInput<T extends Schema.Schema<any>>(
			input: DataInputRef<T>,
		): Effect.Effect<
			T["Encoded"],
			NoSuchElementException | NotComputationNode,
			NodeExecutionContext | RunFunctionAvailableRequirements
		>;
		setOutput<T extends Schema.Schema<any>>(
			output: DataOutputRef<T>,
			data: T,
		): Effect.Effect<void, never, NodeExecutionContext>;
	}
>() {}

export class NodeExecutionContext extends Context.Tag("NodeExecutionContext")<
	NodeExecutionContext,
	{ node: { id: NodeId } }
>() {}



---
File: /packages/domain/src/schema.ts
---

import type { Effect, Option, Schema } from "effect";
import type { YieldWrap } from "effect/Utils";
import type {
	DataInputRef,
	DataOutputRef,
	ExecInputRef,
	ExecOutputRef,
} from "./io";
import type { SchemaRunGeneratorEffect } from "./runtime";

export type NodeSchema<
	TIO = any,
	TEvents = never,
	TEvent extends TEvents = never,
> = ExecSchema<TIO> | PureSchema<TIO> | EventSchema<TIO, TEvents, TEvent>;

export type EffectGenerator<
	Eff extends Effect.Effect<any, any, any>,
	Ret = void,
> = Generator<YieldWrap<Eff>, Ret, never>;

export interface IOFunctionContext {
	in: {
		exec: (id: string) => ExecInputRef;
		data: <T extends Schema.Any>(id: string, type: T) => DataInputRef<T>;
	};
	out: {
		exec: (id: string) => ExecOutputRef;
		data: <T extends Schema.Any>(id: string, type: T) => DataOutputRef<T>;
	};
}

export interface SchemaDefinitionBase {
	type: string;
	name?: string;
}

export interface PureSchemaDefinition<TIO = any> extends SchemaDefinitionBase {
	type: "pure";
	io: (ctx: {
		in: Extract<IOFunctionContext["in"], { data: any }>;
		out: Extract<IOFunctionContext["out"], { data: any }>;
	}) => TIO;
	run: (io: TIO) => EffectGenerator<SchemaRunGeneratorEffect>;
}

export interface PureSchema<TIO = any>
	extends Omit<PureSchemaDefinition<TIO>, "run"> {
	run: ReturnType<PureSchemaDefinition<TIO>["run"]> extends EffectGenerator<
		infer TEff
	>
		? (...args: Parameters<PureSchemaDefinition<TIO>["run"]>) => TEff
		: never;
}

export interface ExecSchemaDefinition<TIO = any> extends SchemaDefinitionBase {
	type: "exec";
	io: (ctx: IOFunctionContext) => TIO;
	run: (
		io: TIO,
	) => EffectGenerator<SchemaRunGeneratorEffect, ExecOutputRef | void>;
}

export interface ExecSchema<TIO = any>
	extends Omit<ExecSchemaDefinition<TIO>, "run"> {
	run: ReturnType<ExecSchemaDefinition<TIO>["run"]> extends EffectGenerator<
		infer TEff
	>
		? (...args: Parameters<ExecSchemaDefinition<TIO>["run"]>) => TEff
		: never;
}

export interface EventSchemaDefinition<
	TIO = any,
	TEvents = never,
	TEvent extends TEvents = never,
> extends SchemaDefinitionBase {
	type: "event";
	event: (e: TEvents) => Option.Option<TEvent>;
	io: (ctx: Omit<IOFunctionContext, "in">) => TIO;
	run: (
		io: TIO,
		data: TEvent,
	) => EffectGenerator<SchemaRunGeneratorEffect, ExecOutputRef>;
}

export interface EventSchema<
	TIO = any,
	TEvents = never,
	TEvent extends TEvents = never,
> extends Omit<EventSchemaDefinition<TIO, TEvents, TEvent>, "run"> {
	run: ReturnType<
		EventSchemaDefinition<TIO, TEvents, TEvent>["run"]
	> extends EffectGenerator<infer TEff, any>
		? (
				...args: Parameters<EventSchemaDefinition<TIO, TEvents, TEvent>["run"]>
			) => TEff
		: never;
}

export type SchemaDefinition<
	TIO = any,
	TEvents = never,
	TEvent extends TEvents = never,
> =
	| ExecSchemaDefinition<TIO>
	| PureSchemaDefinition<TIO>
	| EventSchemaDefinition<TIO, TEvents, TEvent>;



---
File: /packages/domain/src/SubscribableCache.ts
---

import { Cache, type Duration, Effect, PubSub, Stream } from "effect";

export namespace SubscribableCache {
	export interface SubscribableCache<A, E> {
		get: Effect.Effect<A, E>;
		changes: () => Stream.Stream<void, never, never>;
		refresh: Effect.Effect<A, E>;
	}

	export const make = <A, E, R>(options: {
		readonly capacity: number;
		readonly timeToLive: Duration.DurationInput;
		readonly lookup: Effect.Effect<A, E, R>;
	}) =>
		Effect.gen(function* () {
			const changeNotifications = yield* PubSub.unbounded<void>();

			const cache = yield* Cache.make({
				capacity: options.capacity,
				timeToLive: options.timeToLive,
				lookup: (_: void) => options.lookup,
			});

			return {
				get: cache.get(),
				changes: () => Stream.fromPubSub(changeNotifications),
				refresh: cache
					.refresh()
					.pipe(Effect.zipRight(changeNotifications.offer())),
			} as SubscribableCache<A, E>;
		});
}



---
File: /packages/domain/package.json
---

{
	"name": "@macrograph/domain",
	"type": "module",
	"main": "./src/index.ts",
	"types": "./src/index.ts",
	"dependencies": {
		"@effect/rpc": "^0.62.4",
		"@macrograph/web-api": "workspace:*",
		"effect": "^3.16.8"
	},
	"exports": {
		".": "./src/index.ts",
		"./Node": "./src/Node.ts",
		"./Graph": "./src/Graph.ts"
	}
}



---
File: /packages/domain/tsconfig.json
---

{
	"compilerOptions": {
		"target": "ESNext",
		"useDefineForClassFields": true,
		"module": "ESNext",
		"lib": ["ES2021", "DOM", "DOM.Iterable"],
		"skipLibCheck": true,
		"jsx": "preserve",
		"jsxImportSource": "solid-js",

		/* Bundler mode */
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"isolatedModules": true,
		"moduleDetection": "force",
		"noEmit": true,

		/* Linting */
		"strict": true,
		// "noUnusedLocals": true,
		// "noUnusedParameters": true,
		"noUncheckedIndexedAccess": true,
		"noFallthroughCasesInSwitch": true,
		"plugins": [{ "name": "@effect/language-service" }]
	},
	"include": ["src"]
}



---
File: /packages/http-client/src/index.ts
---

export function createHTTPClient<TReqs extends RESTDefinitions, TCtx>(args: {
	root: string;
	fetch: (ctx: TCtx, ...args: Parameters<typeof fetch>) => Promise<any>;
}) {
	return {
		call<TPath extends keyof TReqs>(
			restPath: TPath,
			ctx: TCtx,
			init?: Omit<RequestInit, "method">,
		): Promise<TReqs[TPath]> {
			const [method, path] = splitRESTPath(restPath as any);
			return args.fetch(ctx, `${args.root}${path}`, {
				method,
				...init,
			});
		},
	};
}

type HTTPMethod = "GET" | "POST" | "PUT" | "PATCH";
type RESTPath = `${HTTPMethod} ${string}`;
type RESTDefinitions = {
	[K: RESTPath]: any;
};

function splitRESTPath<T extends RESTPath>(restPath: T) {
	const [method, path]: [HTTPMethod, string] = restPath.split(" ") as any;
	return [method, path] as const;
}



---
File: /packages/http-client/package.json
---

{
	"name": "@macrograph/http-client",
	"private": true,
	"main": "./src/index.ts",
	"types": "./src/index.ts",
	"type": "module",
	"scripts": {
		"clean": "rm -rf .turbo && rm -rf node_modules && rm -rf dist",
		"test": "vitest",
		"typecheck": "tsc -b"
	},
	"devDependencies": {
		"@macrograph/config": "workspace:*"
	},
	"dependencies": {
		"@tanstack/solid-query": "^4.36.1"
	}
}



---
File: /packages/http-client/tsconfig.json
---

{
	"extends": "@macrograph/config/tsconfig",
	"compilerOptions": {
		"outDir": "dist"
	},
	"references": [{ "path": "../runtime" }, { "path": "../typesystem" }]
}



---
File: /packages/server-backend/src/ClientAuth/rpc.ts
---

import { HttpClient, HttpClientRequest } from "@effect/platform";
import { ClientAuth, CloudAuth } from "@macrograph/server-domain";
import {
	Config,
	Effect,
	Mailbox,
	Option,
	Schedule,
	SubscriptionRef,
} from "effect";
import * as Jose from "jose";

import { CloudAPIClient } from "../CloudApi/ApiClient";
import { RealtimeConnection } from "../Realtime";

export const ClientAuthRpcsLive = ClientAuth.Rpcs.toLayer(
	Effect.gen(function* () {
		const { api, makeClient } = yield* CloudAPIClient;

		return {
			ClientLogin: Effect.fn(function* () {
				const mailbox = yield* Mailbox.make<ClientAuth.CloudLoginEvent>();

				yield* Effect.gen(function* () {
					const data = yield* api
						.createDeviceCodeFlow()
						.pipe(Effect.catchAll(() => new CloudAuth.CloudApiError()));

					yield* mailbox.offer({
						type: "started",
						verificationUrlComplete: data.verification_uri_complete,
					});

					const grant = yield* api
						.performAccessTokenGrant({
							urlParams: {
								device_code: data.device_code,
								grant_type: "urn:ietf:params:oauth:grant-type:device_code",
							},
						})
						.pipe(
							Effect.catchAll((error) => {
								if (error._tag === "DeviceFlowError") return Effect.fail(error);
								return Effect.dieMessage(
									"Failed to perform access token grant",
								);
							}),
							Effect.retry({
								schedule: Schedule.fixed(3000),
								while: (error) => error.code === "authorization_pending",
							}),
							Effect.orDie,
						);

					console.log({ grant });

					const userApi = yield* makeClient({
						transformClient: HttpClient.mapRequest(
							HttpClientRequest.setHeader(
								"Authorization",
								`Bearer ${grant.access_token}`,
							),
						),
					});

					const { jwt } = yield* userApi
						.getUserJwt()
						.pipe(Effect.tapError(Effect.log));

					yield* mailbox.offer({ type: "finished", jwt });
				}).pipe(Effect.forkScoped);

				return mailbox;
			}),
			Identify: Effect.fn(function* (payload) {
				const connection = yield* RealtimeConnection;

				const publicKey = yield* Config.string("JWT_PUBLIC_KEY").pipe(
					Effect.tap(Effect.log),
					Effect.andThen((v) =>
						Effect.promise(() =>
							Jose.importSPKI(v.replaceAll("\\n", "\n"), "RS256"),
						),
					),
					Effect.orDie,
				);

				yield* Effect.promise(() => Jose.jwtVerify(payload.jwt, publicKey));

				yield* connection.authJwt.pipe(
					SubscriptionRef.set(Option.some(payload.jwt)),
				);
			}),
		};
	}),
);



---
File: /packages/server-backend/src/CloudApi/ApiClient.ts
---

import {
	FetchHttpClient,
	HttpApiClient,
	HttpClient,
	HttpClientRequest,
} from "@effect/platform";
import { Api } from "@macrograph/web-api";
import { Config, Effect, Option, SubscriptionRef } from "effect";

const CLIENT_ID = "macrograph-server";

export class CloudAPIClient extends Effect.Service<CloudAPIClient>()(
	"CloudAPIClient",
	{
		accessors: true,
		effect: Effect.gen(function* () {
			const token = yield* SubscriptionRef.make(Option.none<string>());

			const baseUrl = yield* Config.string("API_URL").pipe(
				Config.withDefault("https://www.macrograph.app"),
			);

			const httpClient = yield* HttpClient.HttpClient;
			const api = yield* HttpApiClient.make(Api, {
				baseUrl,
				transformClient: HttpClient.mapRequestEffect((req) =>
					token.get.pipe(
						Effect.map(
							Option.match({
								onSome: (token) =>
									req.pipe(
										HttpClientRequest.bearerToken(token),
										HttpClientRequest.setHeader("client-id", CLIENT_ID),
									),
								onNone: () => req,
							}),
						),
					),
				),
			});

			return {
				api,
				token,
				makeClient: (options: {
					readonly transformClient?:
						| ((client: HttpClient.HttpClient) => HttpClient.HttpClient)
						| undefined;
				}) =>
					HttpApiClient.make(Api, {
						baseUrl,
						transformClient: (client) =>
							(options.transformClient?.(client) ?? client).pipe(
								HttpClient.mapRequest(
									HttpClientRequest.setHeader("client-id", CLIENT_ID),
								),
							),
					}).pipe(Effect.provide(HttpClient.HttpClient.context(httpClient))),
			};
		}),
		dependencies: [FetchHttpClient.layer],
	},
) {}



---
File: /packages/server-backend/src/CloudApi/AuthState.ts
---

import { Effect, SubscriptionRef } from "effect";
import { CloudAPIClient } from "./ApiClient";

export class CloudApiAuthState extends Effect.Service<CloudApiAuthState>()(
	"Auth",
	{
		effect: Effect.gen(function* () {
			const apiClient = yield* CloudAPIClient.api;
			const auth = yield* SubscriptionRef.make<null | {
				id: string;
				email: string;
			}>(null);

			const refetch = Effect.gen(function* () {
				const [user, resp] = yield* apiClient.getUser({ withResponse: true });
				yield* SubscriptionRef.set(auth, user);
			});

			yield* refetch.pipe(Effect.fork);

			return {
				get: auth.get,
				refetch,
				changes: auth.changes,
			};
		}),
		dependencies: [CloudAPIClient.Default],
	},
) {}



---
File: /packages/server-backend/src/CloudApi/CredentialsCache.ts
---

import { SubscribableCache } from "@macrograph/domain";
import { Effect, Stream } from "effect";

import { CloudAPIClient } from "./ApiClient";

export class CredentialsCache extends Effect.Service<CredentialsCache>()(
	"CredentialsCache",
	{
		effect: Effect.gen(function* () {
			const { api, token } = yield* CloudAPIClient;

			const credentialsCache = yield* SubscribableCache.make({
				capacity: 1,
				timeToLive: "1 minute",
				lookup: api.getCredentials(),
			});

			yield* token.changes.pipe(
				Stream.runForEach(() =>
					credentialsCache.refresh.pipe(Effect.catchAll(() => Effect.void)),
				),
				Effect.fork,
			);

			return credentialsCache;
		}),
		dependencies: [CloudAPIClient.Default],
	},
) {}



---
File: /packages/server-backend/src/CloudApi/rpc.ts
---

import { CloudAuth } from "@macrograph/server-domain";
import { Effect, Mailbox, Option, Schedule, SubscriptionRef } from "effect";

import { CloudAPIClient } from "./ApiClient";
import { CloudApiAuthState } from "./AuthState";

export const CloudRpcsLive = CloudAuth.Rpcs.toLayer(
	Effect.gen(function* () {
		const { api, token } = yield* CloudAPIClient;
		const authState = yield* CloudApiAuthState;

		return {
			CloudLogin: Effect.fn(function* () {
				const mailbox =
					yield* Mailbox.make<(typeof CloudAuth.CloudLoginEvent)["Type"]>();

				yield* Effect.gen(function* () {
					const data = yield* api
						.createDeviceCodeFlow()
						.pipe(Effect.catchAll(() => new CloudAuth.CloudApiError()));

					yield* mailbox.offer({
						type: "started",
						verificationUrlComplete: data.verification_uri_complete,
					});

					const grant = yield* api
						.performAccessTokenGrant({
							urlParams: {
								device_code: data.device_code,
								grant_type: "urn:ietf:params:oauth:grant-type:device_code",
							},
						})
						.pipe(
							Effect.catchAll((error) => {
								if (error._tag === "DeviceFlowError") return Effect.fail(error);
								return Effect.dieMessage(
									"Failed to perform access token grant",
								);
							}),
							Effect.retry({
								schedule: Schedule.fixed(3000),
								while: (error) => error.code === "authorization_pending",
							}),
							Effect.orDie,
						);

					yield* SubscriptionRef.set(token, Option.some(grant.access_token));

					yield* authState.refetch;

					yield* mailbox.offer({ type: "finished" });
				}).pipe(Effect.forkScoped);

				return mailbox;
			}),
		};
	}),
);



---
File: /packages/server-backend/src/Project/Actions.ts
---

import { type Rpc, RpcSerialization, RpcServer } from "@effect/rpc";
import {
	CredentialsFetchFailed,
	DataInputRef,
	DataOutputRef,
	ExecInputRef,
	ExecOutputRef,
	ExecutionContext,
	ForceRetryError,
	type IOId,
	NodeExecutionContext,
	type NodeSchema,
	NotComputationNode,
	NotEventNode,
	PackageBuilder,
	PackageEngine,
} from "@macrograph/domain";
import { Graph, Node } from "@macrograph/server-domain";
import { Context, Mailbox, Option, PubSub, Stream, pipe } from "effect";
import * as Effect from "effect/Effect";
import type { Package } from "../../../package-sdk/src";

import { CloudAPIClient } from "../CloudApi/ApiClient";
import { CredentialsCache } from "../CloudApi/CredentialsCache";
import { RealtimePubSub } from "../Realtime";
import { type NodeConnections, project } from "../project-data";
import { getNextNodeId } from "./NodeIdCounter";
import { ProjectPackages } from "./Packages";

export class ProjectActions extends Effect.Service<ProjectActions>()(
	"ProjectActions",
	{
		effect: Effect.gen(function* () {
			// const logger = yield* Logger;
			const credentials = yield* CredentialsCache;
			const apiClient = yield* CloudAPIClient.api;
			const realtime = yield* RealtimePubSub;
			const packages = yield* ProjectPackages;

			// const nodes = new Map<number, Node>();

			const getNode = (graphId: Graph.Id, id: Node.Id) =>
				Option.fromNullable(
					project.graphs.get(graphId)?.nodes.find((n) => n.id === id),
				);

			const getGraph = (graphId: Graph.Id) =>
				Option.fromNullable(project.graphs.get(graphId));

			const getPackage = (pkgId: string) =>
				Option.fromNullable(packages.get(pkgId));

			const eventNodes = new Map<Graph.Id, Map<string, Set<Node.Id>>>();

			type SchemaRef = {
				pkgId: string;
				schemaId: string;
			};

			const getSchema = (schemaRef: SchemaRef) =>
				Option.fromNullable(
					packages.get(schemaRef.pkgId)?.pkg.schemas.get(schemaRef.schemaId),
				);

			const createNode = (
				graphId: Graph.Id,
				schemaRef: SchemaRef,
				position: [number, number],
			) =>
				Effect.gen(function* () {
					const schema = yield* getSchema(schemaRef);
					const graph = project.graphs.get(graphId);
					if (!graph) return yield* new Graph.NotFound({ graphId });

					const io: DeepWriteable<Node.IO> = {
						inputs: [],
						outputs: [],
					};

					schema.io({
						out: {
							exec: (id) => {
								io.outputs.push({ id, variant: "exec" });
								return new ExecOutputRef(id as IOId);
							},
							data: (id, type) => {
								io.outputs.push({ id, variant: "data", data: "string" });
								return new DataOutputRef(id, type);
							},
						},
						in: {
							exec: (id) => {
								io.inputs.push({ id, variant: "exec" });
								return new ExecInputRef(id);
							},
							data: (id, type) => {
								io.inputs.push({ id, variant: "data", data: "string" });
								return new DataInputRef(id as IOId, type);
							},
						},
					});

					const node: DeepWriteable<Node.Shape> = {
						schema: schemaRef,
						id: getNextNodeId(),
						inputs: io.inputs,
						outputs: io.outputs,
						position: { x: position[0], y: position[1] },
					};

					if (schema.type === "event") {
						const graphEventNodes =
							eventNodes.get(graphId) ??
							(() => {
								const nodes = new Map<string, Set<Node.Id>>();
								eventNodes.set(graphId, nodes);
								return nodes;
							})();

						const packageEventNodes =
							graphEventNodes.get(schemaRef.pkgId) ??
							(() => {
								const nodes = new Set<Node.Id>();
								graphEventNodes.set(schemaRef.pkgId, nodes);
								return nodes;
							})();

						packageEventNodes.add(node.id);
					}

					graph.nodes.push(node);

					return node;
				});

			type IORef = { nodeId: Node.Id; ioId: string };

			const getInputConnections = (
				graphId: Graph.Id,
				nodeId: Node.Id,
				inputId: IOId,
			) =>
				getGraph(graphId).pipe(
					Option.andThen((graph) =>
						Option.fromNullable(
							graph.connections?.get(nodeId)?.in?.get(inputId),
						),
					),
					Option.getOrElse(() => []),
				);

			const getOutputConnections = (
				graphId: Graph.Id,
				nodeId: Node.Id,
				inputId: IOId,
			) =>
				getGraph(graphId).pipe(
					Option.andThen((graph) =>
						Option.fromNullable(
							graph.connections?.get(nodeId)?.out?.get(inputId),
						),
					),
					Option.getOrElse(() => []),
				);

			const addConnection = Effect.fn(function* (
				graphId: Graph.Id,
				output: IORef,
				input: IORef,
			) {
				const graph = project.graphs.get(graphId);
				if (!graph) return yield* new Graph.NotFound({ graphId });
				const connections = (graph.connections ??= new Map() as NonNullable<
					typeof graph.connections
				>);

				if (Option.isNone(getNode(graphId, output.nodeId)))
					return yield* new Node.NotFound(output);
				if (Option.isNone(getNode(graphId, input.nodeId)))
					return yield* new Node.NotFound(input);

				const upsertNodeConnections = (nodeId: Node.Id) =>
					connections.get(nodeId) ??
					(() => {
						const v: NodeConnections = {};
						connections.set(nodeId, v);
						return v;
					})();

				const outputNodeConnections = upsertNodeConnections(output.nodeId);

				outputNodeConnections.out ??= new Map();
				const outputNodeInputConnections =
					outputNodeConnections.out.get(output.ioId) ??
					(() => {
						const v: Array<[Node.Id, string]> = [];
						outputNodeConnections.out.set(output.ioId, v);
						return v;
					})();
				outputNodeInputConnections.push([input.nodeId, input.ioId]);

				const inputNodeConnections = upsertNodeConnections(input.nodeId);

				inputNodeConnections.in ??= new Map();
				const inputNodeInputConnections =
					inputNodeConnections.in.get(input.ioId) ??
					(() => {
						const v: Array<[Node.Id, string]> = [];
						inputNodeConnections.in.set(input.ioId, v);
						return v;
					})();
				inputNodeInputConnections.push([output.nodeId, output.ioId]);
			});

			const disconnectIO = Effect.fn(function* (
				graphId: Graph.Id,
				io: IORef & { type: "i" | "o" },
			) {
				const graph = project.graphs.get(graphId);
				if (!graph) return yield* new Graph.NotFound({ graphId });
				if (!graph.connections) return;

				const nodeConnections = graph.connections.get(io.nodeId);
				const originConnections =
					io.type === "i" ? nodeConnections?.in : nodeConnections?.out;
				if (!originConnections) return;

				const orginIOConnections = originConnections.get(io.ioId);
				if (!orginIOConnections) return;

				for (const [targetNodeId, targetIOId] of orginIOConnections) {
					const targetNodeConnections = graph.connections.get(targetNodeId);
					const targetConnections =
						io.type === "o"
							? targetNodeConnections?.in
							: targetNodeConnections?.out;
					if (!targetConnections) continue;

					const targetIOConnections = targetConnections.get(targetIOId);
					if (!targetIOConnections) continue;

					const index = targetIOConnections.findIndex(
						([nodeId, ioId]) => ioId === io.ioId && nodeId === io.nodeId,
					);
					if (index !== -1) targetIOConnections.splice(index, 1);
				}

				originConnections.delete(io.ioId);
			});

			const runNode = Effect.fn(function* (graphId: Graph.Id, nodeId: Node.Id) {
				const node = yield* getNode(graphId, nodeId);
				const schema = yield* getSchema(node.schema);

				if (schema.type === "event") return yield* new NotComputationNode();

				const io = schema.io({
					out: {
						exec: (id) => new ExecOutputRef(id as IOId),
						data: (id, type) => new DataOutputRef(id, type),
					},
					in: {
						exec: (id) => new ExecInputRef(id),
						data: (id, type) => new DataInputRef(id as IOId, type),
					},
				});

				return yield* schema.run(io).pipe(
					Effect.map((v) => Option.fromNullable(v ?? undefined)),
					Effect.map(Option.map((output) => ({ output, node }))),
					Effect.provide(NodeExecutionContext.context({ node })),
				);
			});

			const connectionForExecOutput = Effect.fn(function* (
				graphId: Graph.Id,
				ref: ExecOutputRef,
			) {
				const { node } = yield* NodeExecutionContext;
				return Option.fromNullable(
					getOutputConnections(graphId, node.id, ref.id)[0],
				);
			});

			const connectionForDataInput = Effect.fn(function* (
				graphId: Graph.Id,
				ref: DataInputRef<any>,
			) {
				const { node } = yield* NodeExecutionContext;
				return Option.fromNullable(
					getInputConnections(graphId, node.id, ref.id)[0],
				);
			});

			const runEventNode = Effect.fn(function* (
				graphId: Graph.Id,
				eventNode: Node.Shape,
				schema: Extract<NodeSchema<any, any, any>, { type: "event" }>,
				data: unknown,
			) {
				const io = schema.io({
					out: {
						exec: (id) => new ExecOutputRef(id as IOId),
						data: (id, type) => new DataOutputRef(id, type),
					},
				});

				let ret = yield* schema.run(io, data).pipe(
					Effect.map((v) => Option.fromNullable(v ?? undefined)),
					Effect.map(Option.map((output) => ({ output, node: eventNode }))),
					Effect.provide(NodeExecutionContext.context({ node: eventNode })),
				);

				while (Option.isSome(ret)) {
					const { output, node } = ret.value;

					ret = yield* pipe(
						yield* connectionForExecOutput(graphId, output).pipe(
							Effect.provide(Context.make(NodeExecutionContext, { node })),
						),
						Option.andThen((ref) =>
							runNode(graphId, ref[0]).pipe(
								Effect.withSpan("ExecuteNode", {
									attributes: { graphId, nodeId: node.id },
								}),
							),
						),
						Effect.transposeOption,
						Effect.map(Option.flatten),
					);
				}
			});

			const tryExecuteEventNode = Effect.fn(function* (
				graphId: Graph.Id,
				nodeId: Node.Id,
				data: any,
			) {
				const eventNode = yield* getNode(graphId, nodeId);
				const schema = yield* getSchema(eventNode.schema);
				if (schema.type !== "event") return yield* new NotEventNode();

				yield* Effect.sleep("10 millis");

				const eventData = schema.event(data);
				if (Option.isNone(eventData)) return false;

				yield* Effect.gen(function* () {
					const outputData: Map<Node.Id, Record<string, any>> = new Map();

					const getData = (io: IORef) =>
						Option.fromNullable(outputData.get(io.nodeId)?.[io.ioId]);

					const execCtx = ExecutionContext.context({
						traceId: Math.random().toString(),
						getInput: (input) =>
							Effect.gen(function* () {
								const connection = yield* connectionForDataInput(
									graphId,
									input,
								);
								if (Option.isNone(connection)) return "Value";
								const data = getData({
									nodeId: connection.value[0],
									ioId: connection.value[1],
								});
								if (Option.isSome(data)) return data.value;
								yield* runNode(graphId, connection.value[0]).pipe(
									Effect.catchTag("@macrograph/domain/NotComputationNode", () =>
										Effect.die(
											new Error("Cannot get input for a non-computation node"),
										),
									),
								);
								return getData({
									nodeId: connection.value[0],
									ioId: connection.value[1],
								}).pipe(Option.getOrThrow);
							}),
						setOutput: (output, data) =>
							Effect.gen(function* () {
								const { node } = yield* NodeExecutionContext;
								let nodeOutputData = outputData.get(node.id);
								if (!nodeOutputData) {
									nodeOutputData = {};
									outputData.set(node.id, nodeOutputData);
								}
								nodeOutputData[output.id] = data;
							}),
					});

					yield* runEventNode(graphId, eventNode, schema, eventData.value).pipe(
						Effect.provide(execCtx),
					);
				}).pipe(
					Effect.withSpan(`FireEventNode`, { attributes: { graphId, nodeId } }),
				);

				return true;
			});

			const addPackage = <TEvents, TState, TRpcs extends Rpc.Any>(
				name: string,
				unbuiltPkg: Package.UnbuiltPackage<TEvents, TState, TRpcs>,
			) =>
				Effect.gen(function* () {
					const credentialLatch = yield* Effect.makeLatch(true);

					const getCredentials = credentialLatch
						.whenOpen(credentials.get)
						.pipe(Effect.map((c) => c.filter((c) => c.provider === name)));

					const builder = new PackageBuilder(name);

					unbuiltPkg.builder({
						schema: (id, schema) => builder.schema(id, schema),
					});

					let rpcServer, state;

					if (unbuiltPkg.engine) {
						const stateBroadcast = yield* PubSub.unbounded<void>();
						const engine = unbuiltPkg.engine;

						const events = yield* Mailbox.make<{
							event: TEvents;
							// span: Tracer.Span;
						}>();

						const ret = yield* engine
							.builder({
								dirtyState: stateBroadcast.publish(),
								credentials: getCredentials.pipe(
									Effect.catchAll(
										(e) =>
											new CredentialsFetchFailed({ message: e.toString() }),
									),
								),
								refreshCredential: (id) =>
									Effect.gen(function* () {
										yield* credentialLatch.close;

										yield* apiClient
											.refreshCredential({
												path: {
													providerId: name,
													providerUserId: id,
												},
											})
											.pipe(Effect.catchAll(Effect.die));
										yield* credentials.refresh.pipe(
											Effect.catchAll(Effect.die),
										);

										return yield* new ForceRetryError();
									}).pipe(Effect.ensuring(credentialLatch.open)),
								emitEvent: (data) => events.unsafeOffer({ event: data }),
							})
							.pipe(
								Effect.provide(
									PackageEngine.PackageEngineContext.context({
										packageId: name,
									}),
								),
							);

						if (ret.state) {
							yield* credentials.changes().pipe(
								Stream.runForEach(() => stateBroadcast.publish()),
								Effect.ensuring(Effect.log("credentials listener changed")),
								Effect.forkScoped,
							);

							state = {
								get: ret.state,
								changes: stateBroadcast.subscribe,
							};
						}

						if (engine.rpcs && ret.rpc)
							rpcServer = yield* RpcServer.toHttpApp(engine.rpcs, {
								spanPrefix: `PackageRpc.${name}`,
							}).pipe(
								Effect.provide(ret.rpc),
								Effect.provide(RpcServer.layerProtocolHttp({ path: `/` })),
								Effect.provide(RpcSerialization.layerJson),
							);

						yield* Mailbox.toStream(events).pipe(
							Stream.runForEach(({ event }) =>
								Effect.gen(function* () {
									for (const [graphId, graphEventNodes] of eventNodes) {
										const packageEventNodes = graphEventNodes.get(name);
										if (!packageEventNodes) continue;

										for (const nodeId of packageEventNodes) {
											yield* tryExecuteEventNode(graphId, nodeId, event).pipe(
												// Effect.provide(Context.make(Logger, logger)),
												Effect.fork,
											);
										}
									}
								}).pipe(
									Effect.withSpan("Package.Event", {
										root: true,
										attributes: { package: name, event },
									}),
								),
							),
							Effect.forkScoped,
						);
					}

					const pkg = builder.toPackage();

					packages.set(pkg.id, {
						pkg,
						state: Option.fromNullable(state),
						rpcServer: Option.fromNullable(rpcServer),
					});
				});

			const deleteSelection = Effect.fn(function* (
				graphId: Graph.Id,
				selection: Array<Node.Id>,
			) {
				const graph = project.graphs.get(graphId);
				if (!graph) return yield* new Graph.NotFound({ graphId });

				for (const nodeId of selection) {
					const index = graph.nodes.findIndex((node) => node.id === nodeId);
					if (index === -1) continue;
					graph.nodes.splice(index, 1);
				}
			});

			return {
				createNode,
				addPackage,
				addConnection,
				disconnectIO,
				deleteSelection,
			};
		}),
		dependencies: [
			CredentialsCache.Default,
			CloudAPIClient.Default,
			ProjectPackages.Default,
			RealtimePubSub.Default,
		],
	},
) {}



---
File: /packages/server-backend/src/Project/NodeIdCounter.ts
---

import { Node } from "@macrograph/server-domain";

let nodeCounter = Node.Id.make(0);

export function getNextNodeId() {
	return Node.Id.make(++nodeCounter);
}



---
File: /packages/server-backend/src/Project/Packages.ts
---

import type { HttpApp } from "@effect/platform";
import type { Package } from "@macrograph/domain";
import { Effect, type Option, type Queue, type Scope } from "effect";

export type PackageEntry = {
	pkg: Package;
	state: Option.Option<{
		get: Effect.Effect<any>;
		changes: Effect.Effect<Queue.Dequeue<void>, never, Scope.Scope>;
	}>;
	rpcServer: Option.Option<HttpApp.Default<never, Scope.Scope>>;
};

export class ProjectPackages extends Effect.Service<ProjectPackages>()(
	"ProjectPackages",
	{
		effect: Effect.gen(function* () {
			const packages = new Map<string, PackageEntry>();

			return packages;
		}),
	},
) {}



---
File: /packages/server-backend/src/Project/rpc.ts
---

import {
	type Graph,
	type PackageMeta,
	Project,
	type SchemaMeta,
} from "@macrograph/server-domain";
import { Effect, Option } from "effect";

import { project } from "../project-data";
import { ProjectPackages } from "./Packages";

export const ProjectRpcsLive = Project.Rpcs.toLayer(
	Effect.gen(function* () {
		const packages = yield* ProjectPackages;

		return {
			GetProject: Effect.fn(function* () {
				return {
					name: project.name,
					graphs: (() => {
						const ret: Record<string, DeepWriteable<Graph.Shape>> = {};

						for (const [key, value] of project.graphs.entries()) {
							ret[key] = {
								...value,
								connections: (() => {
									const ret: DeepWriteable<Graph.Shape["connections"]> = {};
									if (!value.connections) return ret;

									for (const [
										key,
										nodeConnections,
									] of value.connections.entries()) {
										if (!nodeConnections.out) continue;
										const outputConns = (ret[key] = {} as (typeof ret)[string]);
										for (const [
											key,
											outputConnections,
										] of nodeConnections.out.entries()) {
											outputConns[key] = outputConnections;
										}
									}

									return ret;
								})(),
							};
						}

						return ret;
					})(),
					packages: [...packages.entries()].reduce(
						(acc, [id, { pkg }]) => {
							acc[id] = {
								schemas: [...pkg.schemas.entries()].reduce(
									(acc, [id, schema]) => {
										acc[id] = { id, name: schema.name, type: schema.type };
										return acc;
									},
									{} as Record<string, SchemaMeta>,
								),
							};
							return acc;
						},
						{} as Record<string, PackageMeta>,
					),
				};
			}),
			GetPackageSettings: Effect.fn(function* (payload) {
				const pkg = packages.get(payload.package)!;
				return yield* Option.getOrNull(pkg.state)!.get;
			}),
		};
	}),
);



---
File: /packages/server-backend/src/global.d.ts
---

declare type DeepWriteable<T> = T extends import("effect").Brand.Brand<any>
	? T
	: T extends object
		? { -readonly [P in keyof T]: DeepWriteable<T[P]> }
		: T;



---
File: /packages/server-backend/src/Graph.ts
---

import { SchemaNotFound } from "@macrograph/domain";
import { Graph } from "@macrograph/server-domain";
import { Effect, Option } from "effect";

import { ProjectActions } from "./Project/Actions";
import { RealtimePubSub } from "./Realtime";

import { project } from "./project-data";

export class Graphs extends Effect.Service<Graphs>()("Graphs", {
	sync: () => {
		return {
			get: Effect.fn(function* (id: Graph.Id) {
				return Option.fromNullable(project.graphs.get(id));
			}),
		};
	},
}) {}

export const GraphRpcsLive = Graph.Rpcs.toLayer(
	Effect.gen(function* () {
		const projectActions = yield* ProjectActions;
		const realtime = yield* RealtimePubSub;

		return {
			CreateNode: (payload) =>
				Effect.gen(function* () {
					// yield* ClientAuthJwt;

					const node = yield* projectActions
						.createNode(payload.graphId, payload.schema, [...payload.position])
						.pipe(Effect.mapError(() => new SchemaNotFound(payload.schema)));

					yield* realtime.publish({
						type: "NodeCreated",
						graphId: payload.graphId,
						nodeId: node.id,
						position: node.position,
						schema: payload.schema,
						inputs: node.inputs,
						outputs: node.outputs,
					});

					return {
						id: node.id,
						io: { inputs: node.inputs, outputs: node.outputs },
					};
				}),
			ConnectIO: Effect.fn(function* (payload) {
				yield* projectActions.addConnection(
					payload.graphId,
					payload.output,
					payload.input,
				);

				yield* realtime.publish({
					type: "IOConnected",
					graphId: payload.graphId,
					output: payload.output,
					input: payload.input,
				});
			}),
			DisconnectIO: Effect.fn(function* (payload) {
				yield* projectActions.disconnectIO(payload.graphId, payload.io);

				yield* realtime.publish({
					type: "IODisconnected",
					graphId: payload.graphId,
					io: payload.io,
				});
			}),
			DeleteSelection: Effect.fn(function* (payload) {
				yield* projectActions.deleteSelection(
					payload.graph,
					payload.selection as DeepWriteable<typeof payload.selection>,
				);

				yield* realtime.publish({
					type: "SelectionDeleted",
					graphId: payload.graph,
					selection: payload.selection,
				});
			}),
		};
	}),
);



---
File: /packages/server-backend/src/index.ts
---

import { NodeSdk } from "@effect/opentelemetry";
import {
	type HttpApp,
	HttpRouter,
	HttpServerRequest,
	HttpServerResponse,
} from "@effect/platform";
import type { Route } from "@effect/platform/HttpRouter";
import { RpcServer } from "@effect/rpc";
import {
	Chunk,
	Context,
	FiberRef,
	Layer,
	Mailbox,
	Option,
	PubSub,
	Schema,
	Stream,
	SubscriptionRef,
} from "effect";
import * as Effect from "effect/Effect";
import { getCurrentFiber } from "effect/Fiber";
import * as JOSE from "jose";

// import { RpcsSerialization, ProjectEvent } from "./shared";
// import { NodeRpcsLive } from "./domain/Node/rpc";
// import {
//   RealtimeConnection,
//   RealtimeConnectionId,
// } from "./domain/Realtime/Connection";
// import { RealtimePubSub } from "./domain/Realtime/PubSub";
// import { CloudAPIClient } from "./domain/CloudApi/ApiClient";
// import { CloudApiAuthState } from "./domain/CloudApi/AuthState";
// import { Presence } from "./domain/Presence/Presence";
// import {
//   ClientAuthJwt,
//   RpcAuthMiddleware,
//   RpcRealtimeMiddleware,
// } from "./domain/Rpc/Middleware";
// import { ProjectActions } from "./domain/Project/Actions";
// import { ProjectPackages } from "./domain/Project/Packages";
// import { Graphs } from "./domain/Graph/Graphs";
// import { GraphRpcsLive } from "./domain/Graph/rpc";
// import { ProjectRpcsLive } from "./domain/Project/rpc";
// import { Rpcs } from "./rpc";
// import { PresenceRpcsLive } from "./domain/Presence/rpc";
// import { CloudRpcsLive } from "./domain/CloudApi/rpc";
// import { ClientAuthRpcsLive } from "./domain/ClientAuth/rpc";
import {
	type ProjectEvent,
	Realtime,
	Rpcs,
	RpcsSerialization,
} from "@macrograph/server-domain";
import { ClientAuthRpcsLive } from "./ClientAuth/rpc";
import { CloudAPIClient } from "./CloudApi/ApiClient";
import { CloudApiAuthState } from "./CloudApi/AuthState";
import { CloudRpcsLive } from "./CloudApi/rpc";
import { GraphRpcsLive, Graphs } from "./Graph";
import { NodeRpcsLive } from "./Node";
import { PresenceRpcsLive, PresenceState } from "./Presence";
import { ProjectActions } from "./Project/Actions";
import { ProjectPackages } from "./Project/Packages";
import { ProjectRpcsLive } from "./Project/rpc";
import {
	RealtimeConnection,
	RealtimeConnectionId,
	RealtimePubSub,
} from "./Realtime";

export { ProjectActions } from "./Project/Actions";

const NodeSdkLive = NodeSdk.layer(() => ({
	resource: { serviceName: "mg-server" },
	// Export span data to the console
	// spanProcessor: [
	//   new BatchSpanProcessor(new OTLPTraceExporter()),
	//   new BatchSpanProcessor(new ConsoleSpanExporter()),
	// ],
}));

export const DepsLive = Layer.mergeAll(
	ProjectActions.Default,
	Graphs.Default,
	CloudApiAuthState.Default,
	CloudAPIClient.Default,
	PresenceState.Default,
	ProjectPackages.Default,
	RealtimePubSub.Default,
	NodeSdkLive,
);

const RpcsLive = Layer.mergeAll(
	ProjectRpcsLive,
	GraphRpcsLive,
	NodeRpcsLive,
	PresenceRpcsLive,
	CloudRpcsLive,
	ClientAuthRpcsLive,
);

export const ServerLive = Effect.gen(function* () {
	const packages = yield* ProjectPackages;

	const nextRealtimeClient = (() => {
		let i = 0;
		return () => RealtimeConnectionId.make(i++);
	})();

	const realtimeConnections = new Map<
		number,
		{ auth: Option.Option<{ jwt: string; userId: string }> }
	>();

	const realtimeMiddleware = Realtime.ConnectionRpcMiddleware.context(() =>
		Effect.serviceOption(RealtimeConnection).pipe(
			Effect.map(Option.getOrThrow),
		),
	);

	const realtimeSecretKey = yield* Effect.promise(() =>
		JOSE.generateSecret("HS256"),
	);

	const rpcsWebApp = yield* RpcServer.toHttpAppWebsocket(Rpcs, {
		spanPrefix: "ProjectRpc",
	}).pipe(
		Effect.provide(RpcsLive),
		Effect.provide(NodeRpcsLive),
		Effect.provide(realtimeMiddleware),
		Effect.provide(RpcsSerialization),
	);

	return HttpRouter.empty.pipe(
		HttpRouter.mountApp(
			"/rpc",
			Effect.gen(function* () {
				const req = yield* HttpServerRequest.HttpServerRequest;

				const searchParams = yield* HttpServerRequest.schemaSearchParams(
					Schema.Struct({ token: Schema.String }),
				).pipe(
					Effect.provide(
						HttpServerRequest.ParsedSearchParams.context(
							HttpServerRequest.searchParamsFromURL(
								new URL(req.originalUrl, "s://"),
							),
						),
					),
				);

				const res = yield* Effect.promise(() =>
					JOSE.jwtVerify(searchParams.token, realtimeSecretKey),
				);

				const id = RealtimeConnectionId.make(res.payload.id as number);

				return yield* rpcsWebApp.pipe(
					Effect.provide(
						RealtimeConnection.context({
							id,
							authJwt: yield* SubscriptionRef.make(Option.none<string>()),
						}),
					),
				);
			}),
		),
		HttpRouter.get(
			"/realtime",
			Effect.gen(function* () {
				const req = yield* HttpServerRequest.HttpServerRequest;
				const socket = yield* req.upgrade;
				const writer = yield* socket.writer;

				const connectionId = nextRealtimeClient();

				realtimeConnections.set(connectionId, { auth: Option.none() });

				yield* Effect.gen(function* () {
					yield* writer(
						JSON.stringify({
							type: "identify",
							id: connectionId,
							token: yield* Effect.promise(() =>
								new JOSE.SignJWT({ id: connectionId })
									.setProtectedHeader({ alg: "HS256" })
									.sign(realtimeSecretKey),
							),
						}),
					);

					const mailbox = yield* createEventStream;
					while (true) {
						const a = yield* mailbox.take;
						yield* writer(JSON.stringify(a));
					}
				}).pipe(
					Effect.provide(
						RealtimeConnection.context({
							id: connectionId,
							authJwt: yield* SubscriptionRef.make(Option.none<string>()),
						}),
					),
					Effect.forkScoped,
				);

				yield* socket.runRaw(() => {});

				return HttpServerResponse.empty();
			}).pipe(Effect.scoped),
		),
		allAsMounted(
			"/package/:package/rpc",
			Effect.gen(function* () {
				const { package: pkg } = yield* HttpRouter.schemaPathParams(
					Schema.Struct({ package: Schema.String }),
				);
				const server = packages.get(pkg)?.rpcServer.pipe(Option.getOrUndefined);
				if (!server)
					return HttpServerResponse.text("Package not found", {
						status: 404,
					});

				return yield* server;
			}),
		),
	);
});

const executeAppAsMounted = <A, E, R>(app: HttpApp.HttpApp<A, E, R>) =>
	Effect.gen(function* () {
		const req = yield* HttpServerRequest.HttpServerRequest;
		const fiber = Option.getOrThrow(getCurrentFiber());
		const context = Context.unsafeMake(
			new Map(fiber.getFiberRef(FiberRef.currentContext).unsafeMap),
		);

		context.unsafeMap.set(
			HttpServerRequest.HttpServerRequest.key,
			sliceRequestUrl(req, req.url),
		);

		return yield* app;
	});

function sliceRequestUrl(
	request: HttpServerRequest.HttpServerRequest,
	prefix: string,
) {
	const prefexLen = prefix.length;
	return request.modify({
		url: request.url.length <= prefexLen ? "/" : request.url.slice(prefexLen),
	});
}

const allAsMounted =
	<R1, E1>(path: `/${string}`, handler: Route.Handler<E1, R1>) =>
	<E, R>(self: HttpRouter.HttpRouter<E, R>) =>
		HttpRouter.all(self, path, executeAppAsMounted(handler));

const createEventStream = Effect.gen(function* () {
	const realtimeClient = yield* RealtimeConnection;
	const packages = yield* ProjectPackages;

	const packageStates = Stream.fromIterable(packages.entries()).pipe(
		Stream.filterMap(([name, { state }]) =>
			Option.map(
				state,
				(_): ProjectEvent => ({
					type: "packageAdded",
					data: { package: name },
				}),
			),
		),
	);

	const cloudAuth = yield* CloudApiAuthState;

	const authStream = Stream.concat(
		Stream.fromEffect(cloudAuth.get),
		cloudAuth.changes,
	).pipe(
		Stream.map(
			(data): ProjectEvent => ({
				type: "authChanged",
				data: data ? { id: data.id, email: data.email } : null,
			}),
		),
	);

	const eventQueue = yield* PubSub.unbounded<ProjectEvent>();

	const eventStream = Stream.fromPubSub(eventQueue);

	const packageStatesStream = yield* Chunk.fromIterable(
		packages.entries(),
	).pipe(
		Chunk.filterMap(([name, { state }]) =>
			state.pipe(
				Option.map((state) =>
					Effect.map(state.changes, (state) =>
						Stream.fromQueue(state).pipe(
							Stream.map((): (typeof ProjectEvent)["Type"] => ({
								type: "packageStateChanged",
								package: name,
							})),
						),
					),
				),
			),
		),
		Effect.all,
		Effect.map(Stream.mergeAll({ concurrency: "unbounded" })),
	);

	const presence = yield* PresenceState;
	yield* presence.registerToScope;

	const numSubscriptionsStream = presence.changes.pipe(
		Stream.map((v): ProjectEvent => {
			return {
				type: "PresenceUpdated",
				data: v,
			};
		}),
	);

	const mailbox = yield* Mailbox.make<ProjectEvent>();

	const realtime = yield* RealtimePubSub;

	const realtimeStream = realtime.subscribe().pipe(
		Stream.filterMap(([id, item]) => {
			if (id !== realtimeClient.id) return Option.some(item);
			return Option.none();
		}),
	);

	yield* Stream.mergeAll(
		[
			packageStates,
			authStream,
			eventStream,
			packageStatesStream,
			numSubscriptionsStream,
			realtimeStream,
		],
		{ concurrency: "unbounded" },
	).pipe(
		Stream.runForEach((i) => mailbox.offer(i)),
		Effect.forkScoped,
	);

	return mailbox;
});



---
File: /packages/server-backend/src/Node.ts
---

import { Graph, Node } from "@macrograph/server-domain";
import { Effect } from "effect";

import { Graphs } from "./Graph";
// import { RealtimePubSub } from "../Realtime/PubSub";
// import { Graphs } from "../Graph/Graphs";
import { RealtimePubSub } from "./Realtime";

export const NodeRpcsLive = Node.Rpcs.toLayer(
	Effect.gen(function* () {
		const realtime = yield* RealtimePubSub;

		return {
			SetNodePosition: Effect.fn(function* (payload) {
				const graphs = yield* Graphs;
				const graph = yield* graphs
					.get(payload.graphId)
					.pipe(
						Effect.andThen(
							Effect.catchTag(
								"NoSuchElementException",
								() => new Graph.NotFound({ graphId: payload.graphId }),
							),
						),
					);

				const node = graph.nodes.find((node) => node.id === payload.nodeId);
				if (!node) return;

				node.position = payload.position;

				yield* realtime.publish({
					type: "NodeMoved",
					graphId: graph.id,
					nodeId: node.id,
					position: payload.position,
				});
			}),
			SetNodePositions: Effect.fn(function* (payload) {
				const graphs = yield* Graphs;
				const graph = yield* graphs
					.get(payload.graphId)
					.pipe(
						Effect.andThen(
							Effect.catchTag(
								"NoSuchElementException",
								() => new Graph.NotFound({ graphId: payload.graphId }),
							),
						),
					);

				const positions: Array<{
					node: Node.Id;
					position: { x: number; y: number };
				}> = [];

				for (const [nodeId, position] of payload.positions) {
					const node = graph.nodes.find((node) => node.id === nodeId);
					if (!node) continue;
					node.position = position;
					positions.push({ node: nodeId, position });
				}

				yield* realtime.publish({
					type: "NodesMoved",
					graphId: graph.id,
					positions: payload.positions,
				});
			}),
		};
	}),
);



---
File: /packages/server-backend/src/Presence.ts
---

import { faker } from "@faker-js/faker/locale/en_AU";
import type { Graph, Node, Position } from "@macrograph/server-domain";
import { Presence } from "@macrograph/server-domain";
import { Effect, Scope, Stream, SubscriptionRef } from "effect";

import { RealtimeConnection, type RealtimeConnectionId } from "./Realtime";

const colours = [
	"#BC4D80",
	"#4A7A5B",
	"#9C3FAB",
	"#6C399F",
	"#4A8BB6",
	"#A056A5",
	"#463567",
	"#6B589A",
	"#6D69AA",
	"#D93939",
	"#5AAB5A",
	"#B05481",
	"#438B8C",
	"#5F7BAB",
	"#659960",
	"#A056A0",
	"#537BAF",
	"#BB6064",
	"#4F8559",
	"#AF6B91",
];

export class PresenceState extends Effect.Service<PresenceState>()(
	"PresenceState",
	{
		effect: Effect.gen(function* () {
			const clients = yield* SubscriptionRef.make<
				Record<
					RealtimeConnectionId,
					{
						name: string;
						colour: string;
						mouse?: { graph: Graph.Id; x: number; y: number };
						selection?: { graph: Graph.Id; nodes: Array<Node.Id> };
					}
				>
			>({});

			return {
				registerToScope: Effect.gen(function* () {
					const connection = yield* RealtimeConnection;
					yield* SubscriptionRef.update(clients, (c) => ({
						...c,
						[connection.id]: {
							name: `${faker.word.adjective()} ${faker.word.noun()}`,
							colour: colours[Math.floor(Math.random() * 20)],
						},
					}));

					yield* Scope.addFinalizer(
						yield* Scope.Scope,

						SubscriptionRef.update(clients, (s) => {
							delete s[connection.id];
							return { ...s };
						}),
					);
				}),
				changes: clients.changes.pipe(
					Stream.throttle({
						cost: (c) => c.length,
						duration: "10 millis",
						units: 1,
						strategy: "enforce",
					}),
				),
				setMouse: Effect.fn(function* (graphId: Graph.Id, position: Position) {
					const connection = yield* RealtimeConnection;
					yield* SubscriptionRef.update(clients, (c) => ({
						...c,
						[connection.id]: c[connection.id]
							? {
									...c[connection.id],
									mouse: { graph: graphId, ...position },
								}
							: undefined,
					}));
				}),
				setSelection: Effect.fn(function* (
					...args: [] | [graphId: Graph.Id, nodes: Array<Node.Id>]
				) {
					const connection = yield* RealtimeConnection;

					yield* SubscriptionRef.update(clients, (c) => ({
						...c,
						[connection.id]: c[connection.id]
							? {
									...c[connection.id],
									selection:
										args.length === 0
											? undefined
											: { graph: args[0], nodes: args[1] },
								}
							: c[connection.id],
					}));
				}),
			};
		}),
	},
) {}

export const PresenceRpcsLive = Presence.Rpcs.toLayer(
	Effect.gen(function* () {
		const presence = yield* PresenceState;

		return {
			SetMousePosition: Effect.fn(function* (payload) {
				yield* presence.setMouse(payload.graph, payload.position);
			}),
			SetSelection: Effect.fn(function* ({ value }) {
				if (value === null) yield* presence.setSelection();
				else
					yield* presence.setSelection(
						value.graph,
						value.nodes as DeepWriteable<typeof value.nodes>,
					);
			}),
		};
	}),
);



---
File: /packages/server-backend/src/project-data.ts
---

import { Graph, type Node } from "@macrograph/server-domain";

export type NodeConnections = {
	in?: Map<string, Array<[Node.Id, string]>>;
	out?: Map<string, Array<[Node.Id, string]>>;
};

export type Project = {
	name: string;
	graphs: Map<
		Graph.Id,
		{
			id: Graph.Id;
			name: string;
			nodes: Array<
				{
					id: Node.Id;
					name?: string;
					position: { x: number; y: number };
					schema: { pkgId: string; schemaId: string };
				} & DeepWriteable<Node.IO>
			>;
			connections?: Map<Node.Id, NodeConnections>;
		}
	>;
};

export const project: Project = {
	name: "",
	graphs: new Map([
		[
			Graph.Id.make(0),
			{
				id: Graph.Id.make(0),
				name: "New Graph",
				nodes: [],
			},
		],
	]),
};



---
File: /packages/server-backend/src/Realtime.ts
---

import type { ProjectEvent } from "@macrograph/server-domain";
import {
	Context,
	Effect,
	type Option,
	PubSub,
	Schema,
	Stream,
	type SubscriptionRef,
} from "effect";

export class RealtimePubSub extends Effect.Service<RealtimePubSub>()(
	"ProjectRealtime",
	{
		effect: Effect.gen(function* () {
			const pubsub =
				yield* PubSub.unbounded<[RealtimeConnectionId, ProjectEvent]>();

			return {
				publish: Effect.fn(function* (v: (typeof ProjectEvent)["Type"]) {
					const realtimeClient = yield* RealtimeConnection;

					return yield* pubsub.publish([realtimeClient.id, v]);
				}),
				subscribe: () => Stream.fromPubSub(pubsub),
			};
		}),
	},
) {}

export const RealtimeConnectionId = Schema.Number.pipe(
	Schema.brand("Realtime Client ID"),
);
export type RealtimeConnectionId = (typeof RealtimeConnectionId)["Type"];

export class RealtimeConnection extends Context.Tag("RealtimeConnection")<
	RealtimeConnection,
	{
		id: RealtimeConnectionId;
		authJwt: SubscriptionRef.SubscriptionRef<Option.Option<string>>;
	}
>() {}



---
File: /packages/server-backend/package.json
---

{
	"name": "@macrograph/server-backend",
	"type": "module",
	"main": "./src/index.ts",
	"types": "./src/index.ts",
	"dependencies": {
		"@effect/experimental": "^0.46.1",
		"@effect/opentelemetry": "^0.50.3",
		"@effect/platform": "^0.80.2",
		"@effect/platform-browser": "^0.59.2",
		"@effect/platform-node": "^0.78.1",
		"@effect/rpc": "^0.62.4",
		"@effect/rpc-http": "^0.52.4",
		"@faker-js/faker": "^9.8.0",
		"@macrograph/domain": "workspace:*",
		"@macrograph/package-sdk": "workspace:*",
		"@macrograph/server-domain": "workspace:*",
		"@macrograph/web-api": "workspace:*",
		"@opentelemetry/exporter-trace-otlp-http": "^0.201.1",
		"@opentelemetry/sdk-logs": "^0.201.1",
		"@opentelemetry/sdk-metrics": "^2.0.1",
		"@opentelemetry/sdk-trace-base": "^2.0.1",
		"@opentelemetry/sdk-trace-node": "^2.0.1",
		"@opentelemetry/sdk-trace-web": "^2.0.1",
		"dotenv-cli": "^8.0.0",
		"effect": "^3.16.8",
		"hono": "^4.7.5",
		"jose": "^4.15.9",
		"obs-websocket-js": "^5.0.5"
	},
	"devDependencies": {
		"unplugin-icons": "^0.18.5"
	}
}



---
File: /packages/server-domain/src/ClientAuth.ts
---

import { Rpc, RpcGroup } from "@effect/rpc";
import { Schema } from "effect";

import * as Realtime from "./Realtime";

export const CloudLoginEvent = Schema.Union(
	Schema.Struct({
		type: Schema.Literal("started"),
		verificationUrlComplete: Schema.String,
	}),
	Schema.Struct({
		type: Schema.Literal("finished"),
		jwt: Schema.String,
	}),
);
export type CloudLoginEvent = Schema.Schema.Type<typeof CloudLoginEvent>;

export const Rpcs = RpcGroup.make(
	Rpc.make("ClientLogin", {
		stream: true,
		success: CloudLoginEvent,
	}),
	Rpc.make("Identify", {
		payload: Schema.Struct({
			jwt: Schema.String,
		}),
	}),
).middleware(Realtime.ConnectionRpcMiddleware);



---
File: /packages/server-domain/src/CloudAuth.ts
---

import { Rpc, RpcGroup } from "@effect/rpc";
import { Schema } from "effect";

export const CloudLoginEvent = Schema.Union(
	Schema.Struct({
		type: Schema.Literal("started"),
		verificationUrlComplete: Schema.String,
	}),
	Schema.Struct({
		type: Schema.Literal("finished"),
	}),
);

export class CloudApiError extends Schema.TaggedError<CloudApiError>(
	"CloudApiError",
)("CloudApiError", {}) {}

export const Rpcs = RpcGroup.make(
	Rpc.make("CloudLogin", {
		stream: true,
		success: CloudLoginEvent,
		error: CloudApiError,
	}),
);



---
File: /packages/server-domain/src/errors.ts
---

import { Schema } from "effect";

export class IONotFound extends Schema.TaggedError<IONotFound>()("IONotFound", {
	type: Schema.Union(Schema.Literal("in"), Schema.Literal("out")),
	nodeId: Schema.Int,
}) {}



---
File: /packages/server-domain/src/event.ts
---

import { Schema } from "effect";

import { RpcSerialization } from "@effect/rpc";
import * as Graph from "./Graph";
import * as Node from "./Node";
import { Position, SchemaRef } from "./util";

export type ProjectEvent = Schema.Schema.Type<typeof ProjectEvent>;
export const ProjectEvent = Schema.Union(
	makeEvent("authChanged", {
		data: Schema.NullOr(
			Schema.Struct({ id: Schema.String, email: Schema.String }),
		),
	}),
	makeEvent("packageAdded", {
		data: Schema.Struct({
			package: Schema.String,
		}),
	}),
	makeEvent("packageStateChanged", {
		package: Schema.String,
	}),
	makeEvent("connectedClientsChanged", {
		data: Schema.Int,
	}),
	makeEvent("PresenceUpdated", {
		data: Schema.Record({
			key: Schema.String,
			value: Schema.Struct({
				name: Schema.String,
				colour: Schema.String,
				mouse: Schema.optional(
					Schema.Struct({
						graph: Graph.Id,
						x: Schema.Number,
						y: Schema.Number,
					}),
				),
				selection: Schema.optional(
					Schema.Struct({
						graph: Graph.Id,
						nodes: Schema.Array(Node.Id),
					}),
				),
			}),
		}),
	}),
	makeEvent("NodeMoved", {
		graphId: Graph.Id,
		nodeId: Node.Id,
		position: Position,
	}),
	makeEvent("NodesMoved", {
		graphId: Graph.Id,
		positions: Schema.Array(Schema.Tuple(Node.Id, Position)),
	}),
	Schema.extend(
		makeEvent("NodeCreated", {
			name: Schema.optional(Schema.String),
			graphId: Graph.Id,
			nodeId: Node.Id,
			schema: SchemaRef,
			position: Position,
		}),
		Node.IO,
	),
	makeEvent("IOConnected", {
		graphId: Graph.Id,
		output: Node.IORef,
		input: Node.IORef,
	}),
	makeEvent("IODisconnected", {
		graphId: Graph.Id,
		io: Schema.extend(
			Node.IORef,
			Schema.Struct({ type: Schema.Literal("i", "o") }),
		),
	}),
	makeEvent("SelectionDeleted", {
		graphId: Graph.Id,
		selection: Schema.Array(Node.Id),
	}),
);

function makeEvent<S extends string, F extends Schema.Struct.Fields>(
	type: S,
	fields: F,
) {
	return Schema.Struct({
		...fields,
		type: Schema.Literal(type),
	});
}

export const RpcsSerialization = RpcSerialization.layerJson;



---
File: /packages/server-domain/src/Graph.ts
---

export * from "@macrograph/domain/Graph";

import { Rpc, RpcGroup } from "@effect/rpc";
import { Graph, SchemaNotFound } from "@macrograph/domain";
import { Schema } from "effect";

import * as Node from "./Node";
import * as Realtime from "./Realtime";
import { SchemaRef } from "./util";

export const Shape = Schema.Struct({
	id: Graph.Id,
	name: Schema.String,
	nodes: Schema.Array(Node.Shape),
	connections: Schema.Record({
		key: Schema.String,
		value: Schema.Record({
			key: Schema.String,
			value: Schema.Array(Schema.Tuple(Node.Id, Schema.String)),
		}),
	}),
});
export type Shape = (typeof Shape)["Type"];

export const Rpcs = RpcGroup.make(
	Rpc.make("CreateNode", {
		payload: {
			schema: SchemaRef,
			graphId: Graph.Id,
			position: Schema.Tuple(Schema.Number, Schema.Number),
		},
		success: Schema.Struct({
			id: Node.Id,
			io: Node.IO,
		}),
		error: Schema.Union(SchemaNotFound),
	}),
	Rpc.make("ConnectIO", {
		payload: {
			graphId: Graph.Id,
			output: Node.IORef,
			input: Node.IORef,
		},
		error: Schema.Union(Graph.NotFound, Node.NotFound),
	}),
	Rpc.make("DisconnectIO", {
		payload: Schema.Struct({
			graphId: Graph.Id,
			io: Schema.extend(
				Node.IORef,
				Schema.Struct({ type: Schema.Literal("i", "o") }),
			),
		}),
		error: Schema.Union(Graph.NotFound, Node.NotFound),
	}),
	Rpc.make("DeleteSelection", {
		payload: {
			graph: Graph.Id,
			selection: Schema.Array(Node.Id),
		},
		error: Schema.Union(Graph.NotFound, Node.NotFound),
	}),
).middleware(Realtime.ConnectionRpcMiddleware);



---
File: /packages/server-domain/src/index.ts
---

export * as Graph from "./Graph";
export * as Node from "./Node";
export * as IO from "./IO";
export * as Realtime from "./Realtime";
export * as Project from "./Project";
export * as Presence from "./Presence";
export * as ClientAuth from "./ClientAuth";
export * as CloudAuth from "./CloudAuth";

export * from "./util";
export * from "./errors";
export * from "./event";

import * as ClientAuth from "./ClientAuth";
import * as CloudAuth from "./CloudAuth";
import * as Graph from "./Graph";
import * as Node from "./Node";
import * as Presence from "./Presence";
import * as Project from "./Project";

export const Rpcs = Project.Rpcs.merge(
	Presence.Rpcs,
	Graph.Rpcs,
	Node.Rpcs,
	CloudAuth.Rpcs,
	ClientAuth.Rpcs,
);



---
File: /packages/server-domain/src/IO.ts
---

import { Schema } from "effect";

export const Shape = Schema.Union(
	Schema.Struct({ variant: Schema.Literal("exec") }),
	Schema.Struct({
		variant: Schema.Literal("data"),
		data: Schema.Literal("string", "bool", "float", "int"),
	}),
);
export type Shape = Schema.Schema.Type<typeof Shape>;

export const Variant = Schema.Literal("exec", "data");
export type Variant = Schema.Schema.Type<typeof Variant>;



---
File: /packages/server-domain/src/Node.ts
---

import { Rpc, RpcGroup } from "@effect/rpc";
import { Node } from "@macrograph/domain";
import { Schema } from "effect";

import * as Graph from "./Graph";
import { Shape as IOShape } from "./IO";
import * as Realtime from "./Realtime";
import { Position, SchemaRef } from "./util";

export * from "@macrograph/domain/Node";

export const IO = Schema.Struct({
	inputs: Schema.Array(
		Schema.extend(
			Schema.Struct({
				id: Schema.String,
				name: Schema.optional(Schema.String),
			}),
			IOShape,
		),
	),
	outputs: Schema.Array(
		Schema.extend(
			Schema.Struct({
				id: Schema.String,
				name: Schema.optional(Schema.String),
			}),
			IOShape,
		),
	),
});
export type IO = Schema.Schema.Type<typeof IO>;

export class NotFound extends Schema.TaggedError<NotFound>()(
	"@macrograph/server-domain/Node/NotFound",
	{ nodeId: Node.Id },
) {}

export const Shape = Schema.extend(
	Schema.Struct({
		id: Node.Id,
		name: Schema.optional(Schema.String),
		position: Position,
		schema: SchemaRef,
	}),
	IO,
);
export type Shape = Schema.Schema.Type<typeof Shape>;

export const Rpcs = RpcGroup.make(
	Rpc.make("SetNodePosition", {
		payload: {
			nodeId: Schema.Int,
			graphId: Graph.Id,
			position: Position,
		},
		error: Graph.NotFound,
	}),
	Rpc.make("SetNodePositions", {
		payload: {
			graphId: Graph.Id,
			positions: Schema.Array(Schema.Tuple(Node.Id, Position)),
		},
		error: Schema.Union(Graph.NotFound, NotFound),
	}),
).middleware(Realtime.ConnectionRpcMiddleware);



---
File: /packages/server-domain/src/Presence.ts
---

import { Rpc, RpcGroup } from "@effect/rpc";
import { Schema } from "effect";

import * as Graph from "./Graph";
import * as Node from "./Node";
import * as Realtime from "./Realtime";

export const Rpcs = RpcGroup.make(
	Rpc.make("SetMousePosition", {
		payload: Schema.Struct({
			graph: Graph.Id,
			position: Schema.Struct({ x: Schema.Number, y: Schema.Number }),
		}),
	}),
	Rpc.make("SetSelection", {
		payload: {
			value: Schema.NullOr(
				Schema.Struct({
					graph: Graph.Id,
					nodes: Schema.Array(Node.Id),
				}),
			),
		},
	}),
).middleware(Realtime.ConnectionRpcMiddleware);



---
File: /packages/server-domain/src/Project.ts
---

import { Rpc, RpcGroup } from "@effect/rpc";
import { Schema } from "effect";

import * as Graph from "./Graph";
import * as Realtime from "./Realtime";
import { PackageMeta } from "./util";

export const Rpcs = RpcGroup.make(
	Rpc.make("GetProject", {
		success: Schema.Struct({
			name: Schema.String,
			graphs: Schema.Record({ key: Schema.String, value: Graph.Shape }),
			packages: Schema.Record({ key: Schema.String, value: PackageMeta }),
		}),
	}),
	Rpc.make("GetPackageSettings", {
		payload: { package: Schema.String },
		success: Schema.Any,
	}),
).middleware(Realtime.ConnectionRpcMiddleware);



---
File: /packages/server-domain/src/Realtime.ts
---

import { RpcMiddleware } from "@effect/rpc";
import { Context, type Option, Schema, type SubscriptionRef } from "effect";

export const ConnectionId = Schema.Number.pipe(
	Schema.brand("Realtime Client ID"),
);
export type ConnectionId = Schema.Schema.Type<typeof ConnectionId>;

export class Connection extends Context.Tag("RealtimeConnection")<
	Connection,
	{
		id: ConnectionId;
		authJwt: SubscriptionRef.SubscriptionRef<Option.Option<string>>;
	}
>() {}

export class ConnectionRpcMiddleware extends RpcMiddleware.Tag<ConnectionRpcMiddleware>()(
	"Middleware",
	{
		provides: Connection,
		requiredForClient: true,
	},
) {}



---
File: /packages/server-domain/src/util.ts
---

import { Schema } from "effect";

export const Position = Schema.Struct({
	x: Schema.Number,
	y: Schema.Number,
});
export type Position = Schema.Schema.Type<typeof Position>;

export const SchemaRef = Schema.Struct({
	pkgId: Schema.String,
	schemaId: Schema.String,
});
export type SchemaRef = Schema.Schema.Type<typeof SchemaRef>;

const SchemaMeta = Schema.Struct({
	id: Schema.String,
	name: Schema.optional(Schema.String),
	type: Schema.Literal("exec", "pure", "event"),
});
export type SchemaMeta = Schema.Schema.Type<typeof SchemaMeta>;

export const PackageMeta = Schema.Struct({
	schemas: Schema.Record({ key: Schema.String, value: SchemaMeta }),
});
export type PackageMeta = Schema.Schema.Type<typeof PackageMeta>;



---
File: /packages/server-domain/package.json
---

{
	"name": "@macrograph/server-domain",
	"type": "module",
	"main": "./src/index.ts",
	"types": "./src/index.ts",
	"dependencies": {
		"@effect/experimental": "^0.46.1",
		"@effect/opentelemetry": "^0.50.3",
		"@effect/platform": "^0.80.2",
		"@effect/platform-browser": "^0.59.2",
		"@effect/platform-node": "^0.78.1",
		"@effect/rpc": "^0.62.4",
		"@effect/rpc-http": "^0.52.4",
		"@faker-js/faker": "^9.8.0",
		"@macrograph/web-api": "workspace:*",
		"@macrograph/domain": "workspace:*",
		"@opentelemetry/exporter-trace-otlp-http": "^0.201.1",
		"@opentelemetry/sdk-logs": "^0.201.1",
		"@opentelemetry/sdk-metrics": "^2.0.1",
		"@opentelemetry/sdk-trace-base": "^2.0.1",
		"@opentelemetry/sdk-trace-node": "^2.0.1",
		"@opentelemetry/sdk-trace-web": "^2.0.1",
		"dotenv-cli": "^8.0.0",
		"effect": "^3.16.8",
		"hono": "^4.7.5",
		"jose": "^4.15.9",
		"obs-websocket-js": "^5.0.5"
	}
}



---
File: /packages/server-domain/tsconfig.json
---

{
	"compilerOptions": {
		"target": "ESNext",
		"useDefineForClassFields": true,
		"module": "ESNext",
		"lib": ["ES2021", "DOM", "DOM.Iterable"],
		"skipLibCheck": true,
		"jsx": "preserve",
		"jsxImportSource": "solid-js",

		/* Bundler mode */
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"isolatedModules": true,
		"moduleDetection": "force",
		"noEmit": true,

		/* Linting */
		"strict": true,
		// "noUnusedLocals": true,
		// "noUnusedParameters": true,
		"noUncheckedIndexedAccess": true,
		"noFallthroughCasesInSwitch": true,
		"plugins": [{ "name": "@effect/language-service" }]
	},
	"include": ["src"]
}



---
File: /packages/server-frontend/src/Graph/Context.ts
---

import type { NullableBounds } from "@solid-primitives/bounds";
import { createContextProvider } from "@solid-primitives/context";

const [GraphContextProvider, _useGraphContext] = createContextProvider(
	(props: { bounds: Readonly<NullableBounds> }) => props,
);

export { GraphContextProvider };

export function useGraphContext() {
	const ctx = _useGraphContext();
	if (!ctx)
		throw new Error(
			"useGraphContext must be used within a GraphContextProvider",
		);
	return ctx;
}



---
File: /packages/server-frontend/src/Graph/ContextMenu.tsx
---

import { cx } from "cva";
import { For, Show, createMemo, createSignal } from "solid-js";
import createPresence from "solid-presence";

import type { SchemaRef } from "@macrograph/server-domain";
import { useProjectService } from "../AppRuntime";
import { ProjectState } from "../Project/State";
import { useGraphContext } from "./Context";

export function GraphContextMenu(props: {
	position: { x: number; y: number } | null;
	onSchemaClick: (
		schema: SchemaRef & { position: { x: number; y: number } },
	) => void;
}) {
	const graphCtx = useGraphContext();
	const { state } = useProjectService(ProjectState);

	const [ref, setRef] = createSignal<HTMLElement | null>(null);

	const schemaMenuPresence = createPresence({
		show: () => props.position !== null,
		element: ref,
	});

	const schemaMenuPosition = createMemo(
		(prev: { x: number; y: number } | undefined) => {
			const m = props.position;
			if (m !== null) return m;
			return prev;
		},
	);

	return (
		<Show when={schemaMenuPresence.present() && schemaMenuPosition()}>
			{(position) => (
				<div
					ref={setRef}
					data-open={props.position !== null}
					class={cx(
						"absolute flex flex-col px-2 bg-gray-1 border border-gray-3 rounded-lg text-sm",
						"origin-top-left data-[open='true']:(animate-in fade-in zoom-in-95) data-[open='false']:(animate-out fade-out zoom-out-95)",
					)}
					style={{
						left: `${position().x + (graphCtx.bounds.left ?? 0) - 16}px`,
						top: `${position().y + (graphCtx.bounds.top ?? 0) - 16}px`,
					}}
				>
					<For each={Object.entries(state.packages)}>
						{([pkgId, pkg]) => (
							<div class="py-1">
								<span class="font-bold">{pkgId}</span>
								<div>
									<For each={Object.entries(pkg.schemas)}>
										{([schemaId, schema]) => (
											<button
												class="block bg-transparent w-full text-left px-1 py-0.5 rounded @hover-bg-white/10 active:bg-white/10"
												onClick={() => {
													props.onSchemaClick({
														pkgId,
														schemaId,
														position: {
															x: position().x - 16,
															y: position().y - 16,
														},
													});
												}}
											>
												{schema.name ?? schemaId}
											</button>
										)}
									</For>
								</div>
							</div>
						)}
					</For>
				</div>
			)}
		</Show>
	);
}



---
File: /packages/server-frontend/src/Graph/Graph.tsx
---

import { ContextMenu } from "@kobalte/core/context-menu";
import { Node, type SchemaMeta } from "@macrograph/server-domain";
import type { SchemaRef } from "@macrograph/server-domain";
import { createElementBounds } from "@solid-primitives/bounds";
import { createEventListenerMap } from "@solid-primitives/event-listener";
import { ReactiveMap } from "@solid-primitives/map";
import { createMousePosition } from "@solid-primitives/mouse";
import { mergeRefs } from "@solid-primitives/refs";
import { cx } from "cva";
import { Option } from "effect";
import {
	type ComponentProps,
	For,
	Show,
	createEffect,
	createRoot,
	createSignal,
	onCleanup,
} from "solid-js";
import { batch } from "solid-js";
import type { ValidComponent } from "solid-js";
import IconMaterialSymbolsDeleteOutline from "~icons/material-symbols/delete-outline.jsx";

import { useProjectService } from "../AppRuntime";
import { NodeHeader, NodeRoot } from "../Node";
import { ProjectActions } from "../Project/Actions";
import { type IORef, isTouchDevice } from "../utils";

export const ioPositions = new ReactiveMap<IORef, { x: number; y: number }>();

export type GraphTwoWayConnections = Record<
	Node.Id,
	{
		in?: Record<string, Array<[Node.Id, string]>>;
		out?: Record<string, Array<[Node.Id, string]>>;
	}
>;

export function GraphView(
	props: {
		nodes: DeepWriteable<Node.Shape>[];
		getSchema: (ref: SchemaRef) => Option.Option<SchemaMeta>;
		onSelectionMoved?(items: Array<[Node.Id, { x: number; y: number }]>): void;
		selection: Set<Node.Id>;
		remoteSelections?: Array<{ colour: string; nodes: Set<Node.Id> }>;
		onItemsSelected?(selection: Set<Node.Id>): void;
		onConnectIO?(from: IORef, to: IORef): void;
		onDisconnectIO?(io: IORef): void;
		onContextMenu?(position: { x: number; y: number }): void;
		onContextMenuClose?(): void;
		onDeleteSelection?(): void;
		connections: GraphTwoWayConnections;
	} & Pick<ComponentProps<"div">, "ref" | "children">,
) {
	const [dragState, setDragState] = createSignal<
		| { type: "idle" }
		| {
				type: "dragArea";
				topLeft: { x: number; y: number };
				bottomRight: { x: number; y: number };
		  }
		| { type: "dragIO"; ioRef: IORef; pointerId: number }
		| {
				type: "dragSelection";
				positions: Array<[Node.Id, { x: number; y: number }]>;
		  }
	>({ type: "idle" });

	function getGraphPosition(e: MouseEvent) {
		return { x: e.clientX, y: e.clientY };
	}
	const actions = useProjectService(ProjectActions);

	const [ref, setRef] = createSignal<HTMLDivElement | null>(null);
	const bounds = createElementBounds(ref);

	const mouse = createMousePosition();

	const connections = () => {
		const ret: {
			from: { x: number; y: number };
			to: { x: number; y: number };
			opacity?: number;
		}[] = [];

		const draggingIO = (() => {
			const s = dragState();
			if (s.type === "dragIO") return s.ioRef;
		})();

		if (draggingIO) {
			const position = ioPositions.get(draggingIO);

			if (position) {
				const mousePos = {
					x: mouse.x - (bounds.left ?? 0),
					y: mouse.y - (bounds.top ?? 0),
				};

				ret.push(
					draggingIO.includes(":o:")
						? { from: position, to: mousePos, opacity: 0.5 }
						: { to: position, from: mousePos, opacity: 0.5 },
				);
			}
		}

		for (const [outNodeId, outConnections] of Object.entries(
			props.connections,
		)) {
			if (!outConnections.out) continue;
			for (const [outId, inputs] of Object.entries(outConnections.out)) {
				const outPosition = ioPositions.get(
					`${Node.Id.make(Number(outNodeId))}:o:${outId}`,
				);
				if (!outPosition) continue;

				for (const [inNodeId, inId] of inputs) {
					const inPosition = ioPositions.get(
						`${Node.Id.make(Number(inNodeId))}:i:${inId}`,
					);
					if (!inPosition) continue;

					ret.push({ from: outPosition, to: inPosition });
				}
			}
		}

		for (const { name, payload } of actions.pending) {
			if (name !== "ConnectIO") continue;

			const outPosition = ioPositions.get(
				`${Node.Id.make(Number(payload.output.nodeId))}:o:${
					payload.output.ioId
				}`,
			);
			if (!outPosition) continue;

			const inPosition = ioPositions.get(
				`${Node.Id.make(Number(payload.input.nodeId))}:i:${payload.input.ioId}`,
			);
			if (!inPosition) continue;

			ret.push({ from: outPosition, to: inPosition, opacity: 0.5 });
		}

		return ret;
	};

	return (
		<div
			{...props}
			ref={mergeRefs(setRef, props.ref)}
			class="relative flex-1 flex flex-col gap-4 items-start w-full touch-none select-none"
			onPointerDown={(downEvent) => {
				if (downEvent.button === 0) {
					downEvent.preventDefault();
					props.onContextMenuClose?.();
					const topLeft = {
						x: downEvent.clientX - (bounds.left ?? 0),
						y: downEvent.clientY - (bounds.top ?? 0),
					};

					batch(() => {
						props.onItemsSelected?.(new Set());
						setDragState((s) => {
							if (s.type !== "idle") return s;

							createRoot((dispose) => {
								const timeout = setTimeout(() => {
									if (isTouchDevice) {
										props.onContextMenu?.({
											x: downEvent.clientX - (bounds.left ?? 0),
											y: downEvent.clientY - (bounds.top ?? 0),
										});
									}
								}, 300);

								createEventListenerMap(window, {
									pointermove: (moveEvent) => {
										if (downEvent.pointerId !== moveEvent.pointerId) return;
										clearTimeout(timeout);

										setDragState((s) => {
											if (s.type !== "dragArea") return s;
											return {
												...s,
												bottomRight: {
													x: moveEvent.clientX - (bounds.left ?? 0),
													y: moveEvent.clientY - (bounds.top ?? 0),
												},
											};
										});
									},
									pointerup: (upEvent) => {
										if (downEvent.pointerId !== upEvent.pointerId) return;

										dispose();
									},
								});

								onCleanup(() => {
									try {
										clearTimeout(timeout);
									} catch {}
									setDragState({ type: "idle" });
								});
							});

							return {
								type: "dragArea",
								topLeft,
								bottomRight: topLeft,
							};
						});
					});
				}
			}}
			onContextMenu={(e) => {
				if (!props.onContextMenu) return;
				e.preventDefault();
				props.onContextMenu?.({
					x: e.clientX - (bounds.left ?? 0),
					y: e.clientY - (bounds.top ?? 0),
				});
			}}
		>
			<Connections
				width={bounds.width ?? 0}
				height={bounds.height ?? 0}
				top={bounds.top ?? 0}
				left={bounds.left ?? 0}
				connections={connections()}
			/>
			<ContextMenu>
				<For each={props.nodes}>
					{(node) => (
						<Show when={Option.getOrUndefined(props.getSchema(node.schema))}>
							{(schema) => (
								<NodeRoot
									{...node}
									graphBounds={{
										top: bounds.top ?? 0,
										left: bounds.left ?? 0,
									}}
									position={(() => {
										const ds = dragState();

										if (ds.type !== "dragSelection") return node.position;
										return (
											ds.positions.find((p) => p[0] === node.id)?.[1] ??
											node.position
										);
									})()}
									selected={
										props.selection?.has(node.id) ||
										props.remoteSelections?.find((s) => s.nodes.has(node.id))
											?.colour
									}
									onPinDragStart={(e, type, id) => {
										if (dragState().type !== "idle") return false;

										setDragState({
											type: "dragIO",
											ioRef: `${node.id}:${type}:${id}`,
											pointerId: e.pointerId,
										});

										return true;
									}}
									onPinDragEnd={() => {
										setDragState({ type: "idle" });
									}}
									onPinPointerUp={(e, type, id) => {
										const dragIO = (() => {
											const s = dragState();
											if (s.type === "dragIO") return s;
										})();
										if (!dragIO || e.pointerId !== dragIO.pointerId) return;

										props.onConnectIO?.(
											dragIO.ioRef,
											`${node.id}:${type}:${id}`,
										);
									}}
									onPinDoubleClick={(type, id) => {
										props.onDisconnectIO?.(`${node.id}:${type}:${id}`);
									}}
									connections={{
										in: [
											...Object.entries(props.connections[node.id]?.in ?? {}),
										].flatMap(([id, connections]) => {
											if (connections.length > 0) return id;
											return [];
										}),
										out: [
											...Object.entries(props.connections[node.id]?.out ?? {}),
										].flatMap(([id, connections]) => {
											if (connections.length > 0) return id;
											return [];
										}),
									}}
								>
									<ContextMenu.Trigger<ValidComponent>
										as={(cmProps) => (
											<NodeHeader
												{...cmProps}
												name={node.name ?? schema().name ?? schema().id}
												variant={schema().type}
												onPointerDown={(downEvent) => {
													if (downEvent.button === 0) {
														downEvent.stopPropagation();

														if (downEvent.shiftKey) {
															if (props.selection?.has(node.id)) {
																props.selection?.delete(node.id);
																props.onItemsSelected?.(
																	new Set(props.selection),
																);
															} else {
																props.onItemsSelected?.(
																	new Set([
																		...(props.selection ?? []),
																		node.id,
																	]),
																);
															}
														} else if (props.selection.size <= 1)
															props.onItemsSelected?.(new Set([node.id]));

														const startPositions: Array<
															[Node.Id, { x: number; y: number }]
														> = [];
														props.selection.forEach((nodeId) => {
															const node = props.nodes.find(
																(n) => n.id === nodeId,
															);
															if (!node) return;
															startPositions.push([
																nodeId,
																{ ...node.position },
															]);
														});

														const downPosition = getGraphPosition(downEvent);

														createRoot((dispose) => {
															createEventListenerMap(window, {
																pointermove: (moveEvent) => {
																	if (
																		downEvent.pointerId !== moveEvent.pointerId
																	)
																		return;

																	moveEvent.preventDefault();

																	const movePosition =
																		getGraphPosition(moveEvent);

																	const delta = {
																		x: movePosition.x - downPosition.x,
																		y: movePosition.y - downPosition.y,
																	};

																	const positions = startPositions.map(
																		([nodeId, startPosition]) =>
																			[
																				nodeId,
																				{
																					x: startPosition.x + delta.x,
																					y: startPosition.y + delta.y,
																				},
																			] satisfies [any, any],
																	);

																	props.onSelectionMoved?.(positions);

																	setDragState({
																		type: "dragSelection",
																		positions,
																	});
																},
																pointerup: (upEvent) => {
																	if (downEvent.pointerId !== upEvent.pointerId)
																		return;

																	const upPosition = getGraphPosition(upEvent);

																	const delta = {
																		x: upPosition.x - downPosition.x,
																		y: upPosition.y - downPosition.y,
																	};

																	props.onSelectionMoved?.(
																		startPositions.map(
																			([nodeId, startPosition]) => [
																				nodeId,
																				{
																					x: startPosition.x + delta.x,
																					y: startPosition.y + delta.y,
																				},
																			],
																		),
																	);

																	setDragState({ type: "idle" });

																	dispose();
																},
															});
														});
													} else if (downEvent.button === 2) {
														downEvent.preventDefault();

														if (!props.selection.has(node.id))
															props.onItemsSelected?.(new Set([node.id]));
													}
												}}
											/>
										)}
									/>
								</NodeRoot>
							)}
						</Show>
					)}
				</For>
				<ContextMenu.Portal>
					<ContextMenu.Content<"div">
						class={cx(
							"absolute flex flex-col p-1 bg-gray-1 border border-gray-3 rounded-lg text-sm outline-none min-w-40 *:space-x-1",
							"origin-top-left ui-expanded:(animate-in fade-in zoom-in-95) ui-closed:(animate-out fade-out zoom-out-95)",
						)}
						onPointerDown={(e) => e.stopPropagation()}
					>
						<ContextMenu.Item
							onSelect={() => {
								props.onDeleteSelection?.();
							}}
							class="flex flex-row items-center bg-transparent w-full text-left p-1 rounded @hover-bg-white/10 active:bg-white/10 outline-none"
						>
							<IconMaterialSymbolsDeleteOutline />
							<span>Delete</span>
						</ContextMenu.Item>
					</ContextMenu.Content>
				</ContextMenu.Portal>
			</ContextMenu>
			<Show
				when={(() => {
					const s = dragState();
					if (s.type === "dragArea") return s;
				})()}
			>
				{(dragState) => (
					<div
						class="absolute left-0 top-0 ring-1 ring-yellow-500 bg-yellow-500/10 rounded"
						style={{
							width: `${Math.abs(
								dragState().bottomRight.x - dragState().topLeft.x,
							)}px`,
							height: `${Math.abs(
								dragState().bottomRight.y - dragState().topLeft.y,
							)}px`,
							transform: `translate(${Math.min(
								dragState().topLeft.x,
								dragState().bottomRight.x,
							)}px, ${Math.min(
								dragState().topLeft.y,
								dragState().bottomRight.y,
							)}px)`,
						}}
					/>
				)}
			</Show>
			{props.children}
		</div>
	);
}

function Connections(props: {
	width: number;
	height: number;
	top: number;
	left: number;
	connections: Array<{
		from: { x: number; y: number };
		to: { x: number; y: number };
		opacity?: number;
	}>;
}) {
	const [ref, setRef] = createSignal<HTMLCanvasElement | null>(null);

	createEffect(() => {
		const canvas = ref();
		if (!canvas) return;

		const ctx = canvas.getContext("2d");
		if (!ctx) return;

		const scale = window.devicePixelRatio;

		// canvas.width = Math.floor(props.width * scale);
		// canvas.height = Math.floor(props.height * scale);

		ctx.scale(scale, scale);

		ctx.globalAlpha = 0.75;

		ctx.clearRect(0, 0, props.width, props.height);

		for (const { from, to, opacity } of props.connections) {
			const xDiff = from.x - to.x;
			const cpMagnitude = Math.abs(Math.min(200, xDiff / 2));

			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.moveTo(from.x, from.y);
			ctx.bezierCurveTo(
				from.x + cpMagnitude,
				from.y,
				to.x - cpMagnitude,
				to.y,
				to.x,
				to.y,
			);
			ctx.globalAlpha = 0.75 * (opacity ?? 1);
			ctx.strokeStyle = "white";
			ctx.stroke();
		}

		ctx.scale(1 / scale, 1 / scale);
	});

	return (
		<canvas
			ref={setRef}
			class="absolute inset-0 w-full h-full"
			width={props.width * window.devicePixelRatio}
			height={props.height * window.devicePixelRatio}
		/>
	);
}



---
File: /packages/server-frontend/src/Graph/PresencePointer.tsx
---

import type { ComponentProps } from "solid-js";

import { Avatar } from "../Avatar";

export function PresencePointer(
	props: Pick<ComponentProps<"div">, "style"> & {
		name: string;
		colour: string;
	},
) {
	return (
		<div
			class="bg-white/70 rounded-full size-2 absolute -left-1 -top-1 pointer-events-none"
			style={props.style}
		>
			<Avatar
				name={props.name}
				class="absolute top-full left-full -mt-0.5 -ml-0.5 text-white rounded shadow-lg border border-gray-2"
				style={{ "background-color": props.colour }}
			/>
		</div>
	);
}



---
File: /packages/server-frontend/src/Packages/Context.tsx
---




---
File: /packages/server-frontend/src/Packages/PackagesSettings.ts
---

import { FetchHttpClient } from "@effect/platform";
import { RpcClient, RpcSerialization } from "@effect/rpc";
import { SubscribableCache } from "@macrograph/domain";
import type { SettingsProps } from "@macrograph/package-sdk/ui";
import { ReactiveMap } from "@solid-primitives/map";
import { Context, Effect, Layer, Option } from "effect";
import type { Component } from "solid-js";

import { ProjectRpc } from "../Project/Rpc";

export class GetPackageRpcProtocol extends Effect.Service<GetPackageRpcProtocol>()(
	"GetPackageRpcProtocol",
	{
		sync: () => (id: string) =>
			RpcClient.layerProtocolHttp({ url: `/api/package/${id}/rpc` }).pipe(
				Layer.provide([RpcSerialization.layerJson, FetchHttpClient.layer]),
			),
	},
) {}

export class GetPackageSettings extends Context.Tag("GetPackageSettings")<
	GetPackageSettings,
	(id: string) => Effect.Effect<any, unknown>
>() {}

export type PackageSettings = Readonly<{
	rpcClient: RpcClient.RpcClient<any>;
	SettingsUI: Component<SettingsProps<any, any>>;
	state: SubscribableCache.SubscribableCache<void, any>;
}>;

export interface PackageSettingsModule {
	default: import("solid-js").Component<
		import("@macrograph/package-sdk/ui").SettingsProps<any, any>
	>;
	Rpcs: import("@effect/rpc/RpcGroup").RpcGroup<any>;
}

export class PackagesSettings extends Effect.Service<PackagesSettings>()(
	"PackageEngines",
	{
		accessors: true,
		effect: Effect.gen(function* () {
			const getProtocol = yield* GetPackageRpcProtocol;
			const rpc = yield* ProjectRpc.client;

			const packages = new ReactiveMap<string, PackageSettings>();

			return {
				addPackage: Effect.fn(function* (
					id: string,
					module: PackageSettingsModule,
				) {
					const client = yield* RpcClient.make(module.Rpcs, {
						disableTracing: true,
					}).pipe(Effect.provide(getProtocol(id)));

					packages.set(id, {
						rpcClient: client,
						SettingsUI: module.default,
						state: yield* SubscribableCache.make({
							capacity: 1,
							lookup: rpc.GetPackageSettings({ package: id }),
							timeToLive: 0,
						}),
					});
				}),
				getPackage: (id: string) => Option.fromNullable(packages.get(id)),
				listPackages: () => Array.from<string>(packages.keys()),
			};
		}),
		dependencies: [ProjectRpc.Default, GetPackageRpcProtocol.Default],
	},
) {}



---
File: /packages/server-frontend/src/Presence/ClientListDropdown.tsx
---

import { Popover } from "@kobalte/core/popover";
import { For, Show, createMemo } from "solid-js";
import IconLucideChevronDown from "~icons/lucide/chevron-down";

import { Avatar } from "../Avatar";
import { useRealtimeContext } from "../Realtime";
import { usePresenceContext } from "./Context";

export function ClientListDropdown() {
	const presenceCtx = usePresenceContext();
	const realtimeCtx = useRealtimeContext();

	const clientEntries = createMemo(() => Object.entries(presenceCtx.clients));
	const realtimeId = () => realtimeCtx.id().toString();

	return (
		<Popover
			placement="bottom-start"
			sameWidth
			gutter={4}
			open={clientEntries().length <= 1 ? false : undefined}
		>
			<Show when={clientEntries().find(([id]) => id === realtimeId())}>
				{(data) => (
					<Popover.Trigger
						disabled={clientEntries().length <= 1}
						class="bg-gray-2 p-1 rounded not-disabled:@hover-bg-gray-3 not-disabled:active:bg-gray-3 group flex flex-row items-center space-x-1 outline-none"
					>
						<div class="flex flex-row space-x-1.5 items-center">
							<Avatar
								name={data()[1].name}
								style={{ "background-color": data()[1].colour }}
							/>
							<span>{data()[1].name}</span>
						</div>
						{clientEntries().length > 1 && (
							<IconLucideChevronDown class="ui-expanded:rotate-180 transition-transform" />
						)}
					</Popover.Trigger>
				)}
			</Show>
			<Popover.Portal>
				<Popover.Content
					as="ul"
					class="outline-none flex flex-col bg-gray-1 p-1.5 pt-1 rounded text-sm ui-expanded:(animate-in slide-in-from-top-1 fade-in) ui-closed:(animate-out slide-out-to-top-1 fade-out)"
				>
					<span class="text-xs text-gray-10 mb-1.5">Connected Clients</span>
					<ul class="space-y-1.5">
						<For each={clientEntries()}>
							{([id, data]) => (
								<Show when={id !== realtimeId()}>
									<li>
										<div class="flex flex-row space-x-1.5 items-center">
											<Avatar
												name={data.name}
												style={{
													"background-color": data.colour,
												}}
											/>
											<span>{data.name}</span>
										</div>
									</li>
								</Show>
							)}
						</For>
					</ul>
				</Popover.Content>
			</Popover.Portal>
		</Popover>
	);
}



---
File: /packages/server-frontend/src/Presence/Context.tsx
---

import type { Graph, Node } from "@macrograph/server-domain";
import { createContext } from "solid-js";
import { useContext } from "solid-js";

export type PresenceClient = {
	name: string;
	colour: string;
	mouse?: { graph: Graph.Id; x: number; y: number };
	selection?: { graph: Graph.Id; nodes: Node.Id[] };
};

const PresenceContext = createContext<{
	clients: Record<number, PresenceClient>;
}>();

export const PresenceContextProvider = PresenceContext.Provider;

export function usePresenceContext() {
	const ctx = useContext(PresenceContext);
	if (!ctx)
		throw new Error(
			"usePresenceContext must be used within a PresenceContextProvider",
		);

	return ctx;
}



---
File: /packages/server-frontend/src/Project/Actions.ts
---

import type { Rpc, RpcGroup } from "@effect/rpc";
import type {
	Graph,
	Node,
	Position,
	Rpcs,
	SchemaRef,
} from "@macrograph/server-domain";
import { Chunk, Effect, Option, Stream } from "effect";
import { createStore, produce } from "solid-js/store";

import { type IORef, parseIORef } from "../utils";
import { ProjectRpc } from "./Rpc";
import { ProjectState } from "./State";

export class ProjectActions extends Effect.Service<ProjectActions>()(
	"ProjectActions",
	{
		accessors: true,
		effect: Effect.gen(function* () {
			const rpc = yield* ProjectRpc.client;
			const { setState, actions } = yield* ProjectState;

			type RpcToObject<T> = T extends Rpc.Rpc<
				infer Name,
				infer Payload,
				any,
				any,
				any
			>
				? { name: Name; payload: Payload["Type"] }
				: never;
			type RpcsAsObject = RpcToObject<RpcGroup.Rpcs<typeof Rpcs>>;

			const [pending, setPending] = createStore<Array<RpcsAsObject>>([]);

			const withPending = <T extends RpcsAsObject>(
				name: T["name"],
				payload: T["payload"],
			) => {
				setPending(
					produce((draft) => {
						draft.push({ name, payload } as any);
					}),
				);

				const pendingEntry = pending[pending.length - 1];

				return <A, E, R>(effect: Effect.Effect<A, E, R>) =>
					Effect.ensuring(
						effect,
						Effect.sync(() => {
							const index = pending.findIndex((e) => e === pendingEntry);
							setPending(
								produce((draft) => {
									if (index !== -1) draft.splice(index, 1);
								}),
							);
						}),
					);
			};

			return {
				pending,
				SetNodePositions: (
					graphId: Graph.Id,
					positions: Array<[Node.Id, Position]>,
					ephemeral = true,
				) => {
					rpc.SetNodePositions({ graphId, positions }).pipe(Effect.runPromise);
					setState(
						produce((data) => {
							const graph = data.graphs[graphId];
							if (!graph) return;
							for (const [nodeId, position] of positions) {
								const node = graph.nodes.find((n) => n.id === nodeId);
								if (node) node.position = position;
							}
						}),
					);
				},
				CreateNode: (
					graphId: Graph.Id,
					schema: SchemaRef,
					position: [number, number],
				) =>
					Effect.gen(function* () {
						const resp = yield* rpc.CreateNode({ schema, graphId, position });

						setState(
							produce((data) => {
								data.graphs[graphId]?.nodes.push({
									schema,
									id: resp.id,
									position: { x: position[0], y: position[1] },
									inputs: resp.io.inputs as DeepWriteable<
										typeof resp.io.inputs
									>,
									outputs: resp.io.outputs as DeepWriteable<
										typeof resp.io.outputs
									>,
								});
							}),
						);
					}).pipe(
						withPending("CreateNode", { graphId, schema, position }),
						Effect.runPromise,
					),
				ConnectIO: (graphId: Graph.Id, _one: IORef, _two: IORef) => {
					const one = parseIORef(_one);
					const two = parseIORef(_two);

					let output, input;

					if (one.type === "o" && two.type === "i") {
						output = { nodeId: one.nodeId, ioId: one.id };
						input = { nodeId: two.nodeId, ioId: two.id };
					} else if (one.type === "i" && two.type === "o") {
						output = { nodeId: two.nodeId, ioId: two.id };
						input = { nodeId: one.nodeId, ioId: one.id };
					} else return;

					return Effect.gen(function* () {
						yield* rpc.ConnectIO({ graphId, output, input });

						setState(
							produce((data) => {
								const connections = data.graphs[graphId]?.connections;
								if (!connections) return;

								const outNodeConnections = ((connections[output.nodeId] ??=
									{}).out ??= {});
								const outConnections = (outNodeConnections[output.ioId] ??= []);
								outConnections.push([input.nodeId, input.ioId]);

								const inNodeConnections = ((connections[input.nodeId] ??=
									{}).in ??= {});
								const inConnections = (inNodeConnections[input.ioId] ??= []);
								inConnections.push([output.nodeId, output.ioId]);
							}),
						);
					}).pipe(
						withPending("ConnectIO", { graphId, output, input }),
						Effect.runPromise,
					);
				},
				DisconnectIO: (graphId: Graph.Id, _io: IORef) =>
					Effect.gen(function* () {
						const io = parseIORef(_io);

						yield* rpc.DisconnectIO({
							graphId,
							io: { nodeId: io.nodeId, ioId: io.id, type: io.type },
						});

						setState(
							produce((data) => {
								const connections = data.graphs[graphId]?.connections;
								if (!connections) return;

								const conns =
									io.type === "i"
										? connections[io.nodeId]?.in
										: connections[io.nodeId]?.out;

								if (!conns) return;

								const ioConnections = conns[io.id];
								delete conns[io.id];
								if (!ioConnections) return;

								for (const ioConnection of ioConnections) {
									const [nodeId, ioId] = ioConnection;

									const oppNodeConnections =
										io.type === "i"
											? connections[nodeId]?.out
											: connections[nodeId]?.in;
									if (!oppNodeConnections) continue;

									const oppConnections = oppNodeConnections[ioId];
									if (!oppConnections) continue;

									const index = oppConnections.findIndex(
										([nodeId, inId]) => nodeId === io.nodeId && inId === io.id,
									);
									if (index !== -1) oppConnections.splice(index, 1);
									if (oppConnections.length < 1)
										delete oppNodeConnections[ioId];
								}
							}),
						);
					}).pipe(Effect.runPromise),
				DeleteSelection: (graphId: Graph.Id, selection: Array<Node.Id>) =>
					Effect.gen(function* () {
						yield* rpc.DeleteSelection({ graph: graphId, selection });

						setState(
							produce((prev) => {
								for (const nodeId of selection) {
									actions.deleteNode(prev, { graphId, nodeId });
								}
							}),
						);
					}).pipe(Effect.runPromise),
				CloudLogin: Effect.gen(function* () {
					const getFlowStatus = yield* rpc.CloudLogin().pipe(Stream.toPull);

					const status = yield* getFlowStatus.pipe(
						Effect.map(Chunk.get(0)),
						Effect.map(Option.getOrThrow),
					);
					if (status.type !== "started")
						throw new Error("Flow status is not started");

					window.open(status.verificationUrlComplete);

					const complete = yield* getFlowStatus.pipe(
						Effect.map(Chunk.get(0)),
						Effect.map(Option.getOrThrow),
					);
				}).pipe(Effect.scoped),
			};
		}),
		dependencies: [ProjectRpc.Default, ProjectState.Default],
	},
) {}



---
File: /packages/server-frontend/src/Project/Realtime.ts
---

import { Socket } from "@effect/platform";
import { BrowserSocket } from "@effect/platform-browser";
import type { ProjectEvent } from "@macrograph/server-domain";
import { Chunk, Effect, Layer, Option, Stream } from "effect";

export class ProjectRealtime extends Effect.Service<ProjectRealtime>()(
	"ProjectRealtime",
	{
		scoped: Effect.gen(function* () {
			const socket = yield* Socket.Socket;

			const pull = yield* Stream.never.pipe(
				Stream.pipeThroughChannel(Socket.toChannel(socket)),
				Stream.decodeText(),
				Stream.map(
					(v) =>
						JSON.parse(v) as
							| ProjectEvent
							| { type: "identify"; id: number; token: string },
				),
				Stream.toPull,
			);

			const firstEvent = yield* pull.pipe(
				Effect.map(Chunk.get(0)),
				Effect.map(
					Option.getOrThrowWith(() => new Error("Identify event not received")),
				),
			);

			if (firstEvent.type !== "identify")
				throw new Error(`Invalid first event: ${firstEvent.type}`);

			return {
				id: firstEvent.id,
				token: firstEvent.token,
				stream: Stream.fromPull(Effect.sync(() => pull)),
			};
		}),
		dependencies: [
			Socket.layerWebSocket("/api/realtime").pipe(
				Layer.provide(BrowserSocket.layerWebSocketConstructor),
			),
		],
	},
) {}



---
File: /packages/server-frontend/src/Project/Rpc.ts
---

import { Headers, Socket } from "@effect/platform";
import { BrowserSocket } from "@effect/platform-browser";
import { RpcClient, RpcMiddleware } from "@effect/rpc";
import { Realtime, Rpcs } from "@macrograph/server-domain";
import { RpcsSerialization } from "@macrograph/server-domain";
import { Effect } from "effect";

import { ProjectRealtime } from "./Realtime";

export class ProjectRpc extends Effect.Service<ProjectRpc>()("ProjectRpc", {
	accessors: true,
	scoped: Effect.gen(function* () {
		const realtime = yield* ProjectRealtime;

		const mw = RpcMiddleware.layerClient(
			Realtime.ConnectionRpcMiddleware,
			({ request }) =>
				Effect.succeed({
					...request,
					headers: Headers.set(
						request.headers,
						"realtime-id",
						realtime.id.toString(),
					),
				}),
		);

		return {
			client: yield* RpcClient.make(Rpcs, { disableTracing: true }).pipe(
				Effect.provide(mw),
				Effect.provideService(
					RpcClient.Protocol,
					yield* RpcClient.makeProtocolSocket().pipe(
						Effect.provide(RpcsSerialization),
						Effect.provideService(
							Socket.Socket,
							yield* Socket.makeWebSocket(
								`/api/rpc?token=${encodeURIComponent(realtime.token)}`,
							).pipe(Effect.provide(BrowserSocket.layerWebSocketConstructor)),
						),
					),
				),
			),
		};
	}),
	dependencies: [ProjectRealtime.Default],
}) {}



---
File: /packages/server-frontend/src/Project/State.ts
---

import { type Graph, Node } from "@macrograph/server-domain";
import { Effect } from "effect";
import { createStore } from "solid-js/store";

import type { GraphTwoWayConnections } from "../Graph/Graph";
import { ProjectRpc } from "./Rpc";

export class ProjectState extends Effect.Service<ProjectState>()(
	"ProjectState",
	{
		effect: Effect.gen(function* () {
			const rpc = yield* ProjectRpc.client;

			const _data = yield* rpc.GetProject();
			const data = _data as DeepWriteable<typeof _data>;

			const [state, setState] = createStore({
				...data,
				graphs: Object.entries(data.graphs).reduce(
					(acc, [graphId, graph]) => {
						const connections: GraphTwoWayConnections = {};

						for (const [outNodeId, outNodeConnections] of Object.entries(
							graph.connections,
						)) {
							for (const [outId, outConnections] of Object.entries(
								outNodeConnections,
							)) {
								((connections[Node.Id.make(Number(outNodeId))] ??= {}).out ??=
									{})[outId] = outConnections;

								for (const [inNodeId, inId] of outConnections) {
									(((connections[inNodeId] ??= {}).in ??= {})[inId] ??=
										[]).push([Node.Id.make(Number(outNodeId)), outId]);
								}
							}
						}

						return Object.assign(acc, {
							[graphId]: Object.assign(graph, { connections }),
						});
					},
					{} as Record<
						string,
						Omit<DeepWriteable<Graph.Shape>, "connections"> & {
							connections: GraphTwoWayConnections;
						}
					>,
				),
				auth: null as null | { id: string; email: string },
			});

			const actions = {
				disconnectIO(
					prev: typeof state,
					args: {
						graphId: Graph.Id;
						nodeId: Node.Id;
						type: "i" | "o";
						ioId: string;
					},
				) {
					const graph = prev.graphs[args.graphId];
					if (!graph) return;

					const ioConnections =
						graph.connections[args.nodeId]?.[args.type === "i" ? "in" : "out"];
					if (!ioConnections) return;

					const connections = ioConnections[args.ioId];
					if (!connections) return;
					delete ioConnections[args.ioId];

					for (const [oppNodeId, oppIoId] of connections) {
						const oppNodeConnections = graph.connections[oppNodeId];
						const oppConnections =
							oppNodeConnections?.[args.type === "o" ? "in" : "out"]?.[oppIoId];
						if (!oppConnections) continue;

						const index = oppConnections.findIndex(
							([nodeId, ioId]) => nodeId === args.nodeId && ioId === args.ioId,
						);
						if (index !== -1) oppConnections.splice(index, 1);
					}
				},
				deleteNode(
					prev: typeof state,
					args: {
						graphId: Graph.Id;
						nodeId: Node.Id;
					},
				) {
					const graph = prev.graphs[args.graphId];
					if (!graph) return;

					const nodeConnections = graph.connections[args.nodeId];

					if (nodeConnections?.in)
						for (const ioId of Object.keys(nodeConnections.in)) {
							actions.disconnectIO(prev, {
								graphId: args.graphId,
								nodeId: args.nodeId,
								type: "i",
								ioId,
							});
						}

					if (nodeConnections?.out)
						for (const ioId of Object.keys(nodeConnections.out ?? {})) {
							actions.disconnectIO(prev, {
								graphId: args.graphId,
								nodeId: args.nodeId,
								type: "o",
								ioId,
							});
						}

					const nodeIndex = graph.nodes.findIndex(
						(node) => node.id === args.nodeId,
					);
					if (nodeIndex === -1) return;
					graph.nodes.splice(nodeIndex, 1);
				},
			};

			return { state, setState, actions };
		}),
		dependencies: [ProjectRpc.Default],
	},
) {}



---
File: /packages/server-frontend/src/routes/settings/account.tsx
---

import { EffectButton } from "@macrograph/package-sdk/ui";
import { Show } from "solid-js";

import { useProjectService } from "../../AppRuntime";
import { ProjectActions } from "../../Project/Actions";
import { ProjectState } from "../../Project/State";

export default function Account() {
	const actions = useProjectService(ProjectActions);
	const { state } = useProjectService(ProjectState);

	return (
		<>
			<span class="text-xl font-bold mb-1">Account</span>
			<p class="text-gray-11 mb-3">
				The MacroGraph account this instance is connected to.
			</p>
			<Show
				when={state.auth}
				fallback={
					<EffectButton onClick={() => actions.CloudLogin}>Login</EffectButton>
				}
			>
				{(auth) => (
					<div class="flex flex-row items-center w-full bg-gray-1 rounded-l">
						<span class="px-2 flex-1">{auth().email}</span>
						<EffectButton>Logout</EffectButton>
					</div>
				)}
			</Show>
		</>
	);
}



---
File: /packages/server-frontend/src/routes/index.tsx
---

import { createElementBounds } from "@solid-primitives/bounds";
import { createEventListener } from "@solid-primitives/event-listener";
import { createMousePosition } from "@solid-primitives/mouse";
import { Effect, Option } from "effect";
import { For, Show, createEffect, createSignal } from "solid-js";
import { createStore, reconcile } from "solid-js/store";

import type { Graph, Node } from "@macrograph/server-domain";
import { useProjectService } from "../AppRuntime";
import { GraphContextProvider } from "../Graph/Context";
import { GraphContextMenu } from "../Graph/ContextMenu";
import { GraphView } from "../Graph/Graph";
import { PresencePointer } from "../Graph/PresencePointer";
import { usePresenceContext } from "../Presence/Context";
import { ProjectActions } from "../Project/Actions";
import { ProjectRpc } from "../Project/Rpc";
import { ProjectState } from "../Project/State";
import { useRealtimeContext } from "../Realtime";

const GRAPH_ID = "0";

export default function () {
	const { state } = useProjectService(ProjectState);
	const actions = useProjectService(ProjectActions);
	const rpc = useProjectService(ProjectRpc.client);

	const presence = usePresenceContext();
	const realtime = useRealtimeContext();

	return (
		<div class="flex flex-row flex-1 overflow-hidden">
			<Show when={state.graphs[GRAPH_ID]} keyed>
				{(graph) => {
					const [selection, setSelection] = createStore<
						{ graphId: Graph.Id; items: Set<Node.Id> } | { graphId: null }
					>({ graphId: null });

					const [ref, setRef] = createSignal<HTMLDivElement | null>(null);

					const bounds = createElementBounds(ref);
					const mouse = createMousePosition();

					const [schemaMenu, setSchemaMenu] = createSignal<
						{ open: false } | { open: true; position: { x: number; y: number } }
					>({ open: false });

					createEventListener(window, "keydown", (e) => {
						if (e.code === "Backspace" || e.code === "Delete") {
							if (selection.graphId !== null) {
								actions.DeleteSelection(selection.graphId, [
									...selection.items,
								]);
							}
						} else if (e.code === "Period") {
							if (e.metaKey || e.ctrlKey) {
								setSchemaMenu({
									open: true,
									position: {
										x: mouse.x - (bounds.left ?? 0),
										y: mouse.y - (bounds.top ?? 0),
									},
								});
							}
						}
					});

					createEffect(() => {
						rpc
							.SetSelection({
								value:
									selection.graphId === null
										? null
										: {
												graph: selection.graphId,
												nodes: [...selection.items],
											},
							})
							.pipe(Effect.runPromise);
					});

					createEventListener(
						() => ref() ?? undefined,
						"pointermove",
						(e) => {
							rpc
								.SetMousePosition({
									graph: graph.id,
									position: {
										x: e.clientX - (bounds.left ?? 0),
										y: e.clientY - (bounds.top ?? 0),
									},
								})
								.pipe(Effect.runPromise);
						},
					);

					return (
						<GraphContextProvider bounds={bounds}>
							<GraphView
								ref={setRef}
								nodes={graph.nodes}
								getSchema={(ref) =>
									Option.fromNullable(
										state.packages[ref.pkgId]?.schemas[ref.schemaId],
									)
								}
								selection={
									selection.graphId === graph.id ? selection.items : new Set()
								}
								remoteSelections={Object.entries(presence.clients).flatMap(
									([userId, data]) => {
										if (Number(userId) === realtime.id()) return [];

										if (data.selection?.graph === graph.id)
											return [
												{
													colour: data.colour,
													nodes: new Set(data.selection.nodes),
												},
											];
										return [];
									},
								)}
								onItemsSelected={(items) => {
									setSelection(reconcile({ graphId: graph.id, items }));
								}}
								onConnectIO={(from, to) => {
									actions.ConnectIO(graph.id, from, to);
								}}
								onDisconnectIO={(io) => {
									actions.DisconnectIO(graph.id, io);
								}}
								connections={graph.connections}
								onContextMenu={(position) => {
									setSchemaMenu({ open: true, position });
								}}
								onContextMenuClose={() => {
									setSchemaMenu({ open: false });
								}}
								onSelectionMoved={(items) => {
									if (selection.graphId === null) return;

									actions.SetNodePositions(graph.id, items);
								}}
								onDeleteSelection={() => {
									if (selection.graphId === null) return;
									actions.DeleteSelection(graph.id, [...selection.items]);
								}}
							/>
							<For each={Object.entries(presence.clients)}>
								{(item) => (
									<Show
										when={
											Number(item[0]) !== realtime.id() &&
											item[1].mouse?.graph === graph.id &&
											item[1].mouse
										}
									>
										{(mouse) => (
											<PresencePointer
												style={{
													transform: `translate(${
														mouse().x + (bounds.left ?? 0)
													}px, ${mouse().y + (bounds.top ?? 0)}px)`,
												}}
												name={item[1].name}
												colour={item[1].colour}
											/>
										)}
									</Show>
								)}
							</For>

							<GraphContextMenu
								position={(() => {
									const s = schemaMenu();
									if (s.open) return s.position;
									return null;
								})()}
								onSchemaClick={(schemaRef) => {
									actions.CreateNode(graph.id, schemaRef, [
										schemaRef.position.x,
										schemaRef.position.y,
									]);
									setSchemaMenu({ open: false });
								}}
							/>
						</GraphContextProvider>
					);
				}}
			</Show>
		</div>
	);
}



---
File: /packages/server-frontend/src/routes/packages.[package].tsx
---

import type { SubscribableCache } from "@macrograph/domain";
import { useParams } from "@solidjs/router";
import { Effect, Fiber, Option, Stream } from "effect";
import {
	type Accessor,
	ErrorBoundary,
	Show,
	createEffect,
	createResource,
	onCleanup,
} from "solid-js";
import { Dynamic } from "solid-js/web";

import { useProjectRuntime, useProjectService } from "../AppRuntime";
import { PackagesSettings } from "../Packages/PackagesSettings";

export default function () {
	const params = useParams<{ package: string }>();

	const packagesSettings = useProjectService(PackagesSettings);

	return (
		<ErrorBoundary fallback="Package UI Error">
			<Show
				when={Option.getOrUndefined(
					packagesSettings.getPackage(params.package),
				)}
				keyed
			>
				{(settings) => {
					const state = useSubscribableCache(() => settings.state);

					return (
						<Show when={state()}>
							{(s) => (
								<Dynamic
									component={settings.SettingsUI}
									rpc={settings.rpcClient}
									state={s()}
									globalState={{
										auth: { state: "logged-in", userId: "" },
										logsPanelOpen: false,
									}}
								/>
							)}
						</Show>
					);
				}}
			</Show>
		</ErrorBoundary>
	);
}

export function useSubscribableCache<A, E>(
	cache: Accessor<SubscribableCache.SubscribableCache<A, E>>,
) {
	const projectRuntime = useProjectRuntime();

	const [state, actions] = createResource(cache, (cache) => {
		return cache.get.pipe(projectRuntime.runPromise);
	});

	createEffect(() => {
		const fiber = cache()
			.changes()
			.pipe(
				Stream.runForEach(() =>
					Effect.sync(() => {
						actions.refetch();
					}),
				),
				projectRuntime.runFork,
			);

		onCleanup(() => Fiber.interrupt(fiber).pipe(projectRuntime.runFork));
	});

	return state;
}



---
File: /packages/server-frontend/src/routes/packages.tsx
---

import { A } from "@solidjs/router";
import { For, type ParentProps, Suspense } from "solid-js";

import { useProjectService } from "../AppRuntime";
import { PackagesSettings } from "../Packages/PackagesSettings";
import { usePresenceContext } from "../Presence/Context";

export default function (props: ParentProps) {
	const packagesSettings = useProjectService(PackagesSettings);
	const presenceCtx = usePresenceContext();

	return (
		<div class="flex flex-row divide-x divide-gray-5 flex-1">
			<nav class="w-40 text-sm p-2 shrink-0 flex flex-col">
				<ul class="space-y-1 flex-1">
					<For each={packagesSettings.listPackages()}>
						{(id) => (
							<li>
								<A
									href={id}
									activeClass="bg-gray-5"
									inactiveClass="bg-transparent hover:bg-gray-4"
									class="block text-left w-full px-2 py-1 outline-none focus-visible:outline-solid rounded focus-visible:(outline-(1 yellow-4 offset-0))"
								>
									{id}
								</A>
							</li>
						)}
					</For>
				</ul>
				<div>{Object.keys(presenceCtx.clients).length} Clients Connected</div>
			</nav>
			<div class="max-w-lg w-full flex flex-col items-stretch p-4 gap-4 text-sm">
				<Suspense>{props.children}</Suspense>
			</div>
		</div>
	);
}



---
File: /packages/server-frontend/src/routes/Routes.tsx
---

import { Navigate, type RouteDefinition } from "@solidjs/router";
import { Show, lazy } from "solid-js";

import { useProjectService } from "../AppRuntime";
import { ProjectState } from "../Project/State";

export const routes: RouteDefinition[] = [
	{
		path: "/",
		component: lazy(() => import("./index")),
	},
	{
		path: "/settings",
		component: lazy(() => import("./settings")),
		children: [
			{
				path: "/",
				component: () => <Navigate href="account" />,
			},
			{
				path: "/account",
				component: lazy(() => import("./settings/account")),
			},
		],
	},
	{
		path: "/packages",
		children: [
			{
				path: "/",
				component: () => {
					const { state } = useProjectService(ProjectState);

					return (
						<Show when={Object.keys(state.packages)[0]}>
							{(href) => <Navigate href={href()} />}
						</Show>
					);
				},
			},
			{
				path: "/:package",
				component: lazy(() => import("./packages.[package]")),
			},
		],
		component: lazy(() => import("./packages")),
	},
];



---
File: /packages/server-frontend/src/routes/settings.tsx
---

import { A } from "@solidjs/router";
import { For, type ParentProps } from "solid-js";

export default function Settings(props: ParentProps) {
	return (
		<div class="flex flex-row divide-x divide-gray-5 flex-1">
			<nav class="w-40 text-sm p-2 shrink-0 flex flex-col">
				<ul class="space-y-1 flex-1">
					<For each={[{ name: "Account", href: "account" }]}>
						{(item) => (
							<li>
								<A
									href={item.href}
									activeClass="bg-gray-5"
									inactiveClass="bg-transparent hover:bg-gray-4"
									class="block text-left w-full px-2 py-1 outline-none focus-visible:outline-solid rounded focus-visible:(outline-(1 yellow-4 offset-0))"
								>
									{item.name}
								</A>
							</li>
						)}
					</For>
				</ul>
			</nav>
			<div class="max-w-lg w-full flex flex-col items-stretch p-4 text-sm">
				{props.children}
			</div>
		</div>
	);
}



---
File: /packages/server-frontend/src/AppRuntime.tsx
---

import { type Effect, Layer, type ManagedRuntime } from "effect";
import { createContext, useContext } from "solid-js";

import { ClientAuth } from "./Auth";
import { PackagesSettings } from "./Packages/PackagesSettings";
import { ProjectActions } from "./Project/Actions";
import { ProjectRealtime } from "./Project/Realtime";
import { ProjectRpc } from "./Project/Rpc";
import { ProjectState } from "./Project/State";

export namespace ProjectRuntime {
	export type ProjectRuntime = ManagedRuntime.ManagedRuntime<
		Context,
		Layer.Layer.Error<typeof ProjectRuntime.layer>
	>;

	export type Context =
		| Layer.Layer.Success<typeof ProjectRuntime.layer>
		| Layer.Layer.Context<typeof ProjectRuntime.layer>;

	export const layer = Layer.mergeAll(
		ProjectRealtime.Default,
		PackagesSettings.Default,
		ProjectActions.Default,
		ProjectState.Default,
		ProjectRpc.Default,
		ClientAuth.Default,
	);
}

const ProjectRuntimeContext = createContext<ProjectRuntime.ProjectRuntime>();

export const ProjectRuntimeProvider = ProjectRuntimeContext.Provider;

export function useProjectRuntime() {
	const ctx = useContext(ProjectRuntimeContext);
	if (!ctx)
		throw new Error(
			"useProjectRuntime must be used within ProjectRuntimeProvider",
		);

	return ctx;
}

export function useProjectService<T>(
	service: Effect.Effect<
		T,
		never,
		ManagedRuntime.ManagedRuntime.Context<ProjectRuntime.ProjectRuntime>
	>,
) {
	const runtime = useProjectRuntime();

	return runtime.runSync(service);
}



---
File: /packages/server-frontend/src/Auth.ts
---

import { Chunk, Effect, Option, Stream, SubscriptionRef } from "effect";
import { ProjectRpc } from "./Project/Rpc";

export class ClientAuth extends Effect.Service<ClientAuth>()("ClientAuth", {
	effect: Effect.gen(function* () {
		const rpc = yield* ProjectRpc.client;

		const jwt = yield* SubscriptionRef.make(Option.none<string>());

		return {
			login: Effect.gen(function* () {
				const getFlowStatus = yield* rpc
					.ClientLogin()
					.pipe(Stream.toPull, Effect.map(Effect.orDie));

				const status = yield* getFlowStatus.pipe(
					Effect.map(Chunk.get(0)),
					Effect.map(Option.getOrThrow),
				);
				if (status.type !== "started")
					throw new Error("Flow status is not started");

				window.open(status.verificationUrlComplete);

				const complete = yield* getFlowStatus.pipe(
					Effect.map(Chunk.get(0)),
					Effect.map(Option.getOrThrow),
				);

				if (complete.type !== "finished")
					throw new Error("Flow status is not finished");

				yield* SubscriptionRef.set(jwt, Option.some(complete.jwt));

				yield* rpc.Identify({ jwt: complete.jwt });
			}).pipe(Effect.scoped),
			jwt,
		};
	}),
	dependencies: [ProjectRpc.Default],
}) {}



---
File: /packages/server-frontend/src/Avatar.tsx
---

import { cx } from "cva";
import type { ComponentProps } from "solid-js";

export function Avatar(props: { name: string } & ComponentProps<"div">) {
	return (
		<div
			{...props}
			class={cx(
				"rounded-full size-5.5 flex items-center justify-center text-[0.65rem]",
				props.class,
			)}
		>
			<span>
				{props.name
					?.split(" ")
					.slice(0, 2)
					.map((s) => s[0]?.toUpperCase())}
			</span>
		</div>
	);
}



---
File: /packages/server-frontend/src/global.d.ts
---

declare type DeepWriteable<T> = T extends import("effect").Brand.Brand<any>
	? T
	: T extends object
		? { -readonly [P in keyof T]: DeepWriteable<T[P]> }
		: T;



---
File: /packages/server-frontend/src/Header.tsx
---

import { Dialog } from "@kobalte/core";
import { Button, EffectButton } from "@macrograph/package-sdk/ui";
import { A } from "@solidjs/router";
import type { ValidComponent } from "solid-js";
import { useProjectService } from "./AppRuntime";
import { ClientAuth } from "./Auth";
import { ClientListDropdown } from "./Presence/ClientListDropdown";

export function Header() {
	return (
		<div class="flex flex-row gap-2 px-2 items-center h-10 bg-gray-2 z-10">
			<A
				class="p-1 px-2 rounded hover:bg-gray-3"
				inactiveClass="bg-gray-2"
				activeClass="bg-gray-3"
				href="/settings"
			>
				Settings
			</A>
			<A
				class="p-1 px-2 rounded hover:bg-gray-3"
				inactiveClass="bg-gray-2"
				activeClass="bg-gray-3"
				href="/packages"
			>
				Packages
			</A>
			<A
				class="p-1 px-2 rounded hover:bg-gray-3"
				inactiveClass="bg-gray-2"
				activeClass="bg-gray-3"
				href="/"
				end
			>
				Graph
			</A>
			<div class="flex-1" />
			<ClientListDropdown />
			<ClientLoginButton />
		</div>
	);
}

function ClientLoginButton() {
	const clientAuth = useProjectService(ClientAuth);

	return (
		<>
			<Dialog.Root>
				<Dialog.Trigger<ValidComponent> as={(props) => <Button {...props} />}>
					Login
				</Dialog.Trigger>

				<Dialog.Portal>
					<Dialog.Overlay class="fixed inset-0 z-50 bg-black/20 animate-in fade-in" />
					<div class="fixed inset-0 z-50 flex items-center justify-center animate-in fade-in zoom-in-95">
						<Dialog.Content class="z-50 bg-gray-1 p-4">
							<span>Login</span>
							<p>Use the button below to login via macrograph.app</p>
							<EffectButton onClick={() => clientAuth.login}>
								Open Login Page
							</EffectButton>
						</Dialog.Content>
					</div>
				</Dialog.Portal>
			</Dialog.Root>
		</>
	);
}



---
File: /packages/server-frontend/src/index.tsx
---

import { Router } from "@solidjs/router";
import { ManagedRuntime, Match, Option, Stream } from "effect";
import * as Effect from "effect/Effect";
import { createStore, produce, reconcile } from "solid-js/store";
import { ErrorBoundary, render } from "solid-js/web";

import "virtual:uno.css";
import "@unocss/reset/tailwind-compat.css";
import "./style.css";

import { ProjectRuntime, ProjectRuntimeProvider } from "./AppRuntime";
import { Layout } from "./Layout";
import { PackagesSettings } from "./Packages/PackagesSettings";
import {
	type PresenceClient,
	PresenceContextProvider,
} from "./Presence/Context";
import { ProjectRealtime } from "./Project/Realtime";
import { ProjectState } from "./Project/State";
import { RealtimeContextProvider } from "./Realtime";
import { routes } from "./routes/Routes";

export { PackagesSettings } from "./Packages/PackagesSettings";

const [packages, setPackages] = createStore<Record<string, { id: string }>>({});

export const runtime = ManagedRuntime.make(ProjectRuntime.layer);

export class UI extends Effect.Service<UI>()("UI", {
	effect: Effect.gen(function* () {
		const [presenceClients, setPresence] = createStore<
			Record<number, PresenceClient>
		>({});

		const realtime = yield* ProjectRealtime;
		const tagType = Match.discriminator("type");

		realtime.stream.pipe(
			Stream.runForEach(
				Effect.fn(function* (data) {
					if (data.type === "identify")
						throw new Error("Duplicate identify event");

					const { setState, actions } = yield* ProjectState;
					const pkgSettings = yield* PackagesSettings;

					yield* Match.value(data).pipe(
						tagType("authChanged", ({ data }) =>
							Effect.sync(() => {
								setState("auth", data);
							}),
						),
						tagType("packageStateChanged", (data) => {
							return pkgSettings.getPackage(data.package).pipe(
								Option.map((pkg) => pkg.state.refresh),
								Effect.transposeOption,
							);
						}),
						tagType("connectedClientsChanged", ({ data }) =>
							Effect.sync(() => {} /*setConnectedClients(data)*/),
						),
						tagType("packageAdded", ({ data }) =>
							Effect.sync(() => {
								if (packages[data.package]) return;
								setPackages(data.package, { id: data.package });
							}),
						),
						tagType("NodeMoved", (data) =>
							Effect.sync(() => {
								setState(
									produce((prev) => {
										const node = prev.graphs[data.graphId]?.nodes.find(
											(n) => n.id === data.nodeId,
										);

										if (node) node.position = data.position;
									}),
								);
							}),
						),
						tagType("NodesMoved", (data) =>
							Effect.sync(() => {
								setState(
									produce((prev) => {
										const graph = prev.graphs[data.graphId];
										if (!graph) return;

										for (const [nodeId, position] of data.positions) {
											const node = graph.nodes.find((n) => n.id === nodeId);
											if (node) node.position = position;
										}
									}),
								);
							}),
						),
						tagType("NodeCreated", (data) =>
							Effect.sync(() => {
								setState(
									produce((prev) => {
										const nodes = prev.graphs[data.graphId]?.nodes;
										if (!nodes) return;

										nodes.push({
											name: data.name,
											id: data.nodeId,
											inputs: data.inputs as DeepWriteable<typeof data.inputs>,
											outputs: data.outputs as DeepWriteable<
												typeof data.outputs
											>,
											position: data.position,
											schema: data.schema,
										});
									}),
								);
							}),
						),
						tagType("IOConnected", (data) =>
							Effect.sync(() => {
								setState(
									produce((prev) => {
										const graph = prev.graphs[data.graphId];
										if (!graph) return;

										const outNodeConnections = (graph.connections[
											data.output.nodeId
										] ??= {});
										const outConnections = ((outNodeConnections.out ??= {})[
											data.output.ioId
										] ??= []);
										outConnections.push([data.input.nodeId, data.input.ioId]);

										const inNodeConnections = (graph.connections[
											data.input.nodeId
										] ??= {});
										const inConnections = ((inNodeConnections.in ??= {})[
											data.input.ioId
										] ??= []);
										inConnections.push([data.output.nodeId, data.output.ioId]);
									}),
								);
							}),
						),
						tagType("IODisconnected", (data) =>
							Effect.sync(() => {
								// tbh probably gonna need to serialize everything that got disconnected

								setState(
									produce((prev) => {
										actions.disconnectIO(prev, {
											graphId: data.graphId,
											nodeId: data.io.nodeId,
											ioId: data.io.ioId,
											type: data.io.type,
										});
									}),
								);
							}),
						),
						tagType("PresenceUpdated", (data) =>
							Effect.sync(() => {
								setPresence(
									reconcile(data.data as DeepWriteable<typeof data.data>),
								);
							}),
						),
						tagType("SelectionDeleted", (data) =>
							Effect.sync(() => {
								setState(
									produce((prev) => {
										const graph = prev.graphs[data.graphId];
										if (!graph) return;

										for (const nodeId of data.selection) {
											actions.deleteNode(prev, {
												graphId: data.graphId,
												nodeId,
											});
										}
									}),
								);
							}),
						),
						Match.exhaustive,
					);
				}),
			),
			runtime.runFork,
		);

		const dispose = render(
			() => (
				<ProjectRuntimeProvider value={runtime}>
					<RealtimeContextProvider value={{ id: () => realtime.id }}>
						<PresenceContextProvider value={{ clients: presenceClients }}>
							<ErrorBoundary
								fallback={(e) => {
									console.error(e);
									return (
										<div>
											{e.toString()}
											<pre>{e.stack}</pre>
										</div>
									);
								}}
							>
								<Router root={Layout}>{routes}</Router>
							</ErrorBoundary>
						</PresenceContextProvider>
					</RealtimeContextProvider>
				</ProjectRuntimeProvider>
			),
			document.getElementById("app")!,
		);

		return yield* Effect.never;

		return { dispose };
	}),
}) {}



---
File: /packages/server-frontend/src/Layout.tsx
---

import type { ParentProps } from "solid-js";

import { Header } from "./Header";

export function Layout(props: ParentProps) {
	return (
		<div class="w-full h-full flex flex-col overflow-hidden text-sm *:select-none *:cursor-default divide-y divide-gray-5">
			<Header />
			<div class="flex flex-row flex-1 divide-x divide-gray-5">
				{props.children}
				{/* <Show when={globalState.logsPanelOpen}>
            <div class="p-2 w-80">Logs</div>
          </Show> */}
			</div>
		</div>
	);
}



---
File: /packages/server-frontend/src/Node.tsx
---

import type { Node } from "@macrograph/server-domain";
import { createEventListener } from "@solid-primitives/event-listener";
import { cx } from "cva";
import { Match } from "effect";
import {
	type Accessor,
	type ComponentProps,
	For,
	type ParentProps,
	createEffect,
	createRoot,
	createSignal,
	onCleanup,
} from "solid-js";
import type { DOMElement } from "solid-js/jsx-runtime";

import { ioPositions } from "./Graph/Graph";
import { isTouchDevice } from "./utils";

type DataType = "string" | "int" | "float" | "bool";
type NodeVariant = "event" | "base" | "exec" | "pure";

export function NodeRoot(
	props: ParentProps<
		{
			id: Node.Id;
			position: { x: number; y: number };
			selected?: boolean | string;
			graphBounds: { left: number; top: number };
			onPinDragStart?(
				event: PointerEvent,
				type: "i" | "o",
				id: string,
			): boolean;
			onPinDragEnd?(
				type: "i" | "o",
				id: string,
				position: { x: number; y: number },
			): void;
			onPinPointerUp?(event: PointerEvent, type: "i" | "o", id: string): void;
			onPinDoubleClick?(type: "i" | "o", id: string): void;
			connections?: {
				in?: string[];
				out?: string[];
			};
		} & DeepWriteable<Node.IO>
	>,
) {
	const nodeBounds = () => {
		return {
			left: props.position.x + props.graphBounds.left,
			top: props.position.y + props.graphBounds.top,
		};
	};

	function useIOPositionTrack(
		index: Accessor<number>,
		id: string,
		type: "i" | "o",
		ref: Accessor<HTMLDivElement | undefined>,
	) {
		createEffect(() => {
			index();

			const element = ref();
			if (!element) return;

			const rect = element.getBoundingClientRect();

			const position = {
				x: props.position.x + (rect.left - nodeBounds().left) + rect.width / 2,
				y: props.position.y + (rect.top - nodeBounds().top) + rect.height / 2,
			};

			ioPositions.set(`${props.id}:${type}:${id}`, position);
		});

		onCleanup(() => {
			ioPositions.delete(`${props.id}:${type}:${id}`);
		});
	}

	function onPinPointerDown(
		event: PointerEvent & { target: DOMElement },
		id: string,
		type: "i" | "o",
		onPointerUp: () => void,
	) {
		const res = props.onPinDragStart?.(event, type, id);
		if (!res) return false;

		// necessary to avoid touch events going to the orignating element instead of the window on mobile
		if (event.target.hasPointerCapture(event.pointerId))
			event.target.releasePointerCapture(event.pointerId);

		createRoot((dispose) => {
			createEventListener(window, "pointerup", (upEvent) => {
				props.onPinDragEnd?.(type, id, {
					x: upEvent.clientX - props.graphBounds.left,
					y: upEvent.clientY - props.graphBounds.top,
				});
				onPointerUp();
				dispose();
			});
		});

		return true;
	}

	return (
		<div
			class={cx(
				"absolute rounded-lg overflow-hidden text-xs",
				"bg-black/75 border-black/75 border-2",
				props.selected && "ring-2 opacity-100",
				props.selected === true && "ring-yellow-500",
				props.selected,
			)}
			style={{
				transform: `translate(${props.position.x}px, ${props.position.y}px)`,
				"--un-ring-color":
					typeof props.selected === "string" ? props.selected : undefined,
			}}
			onPointerDown={(e) => {
				e.stopPropagation();
			}}
		>
			{props.children}
			<div class="flex flex-row gap-2 text-xs text-sm">
				<div class="px-1.5 py-2 flex flex-col gap-2.5 items-start">
					<For each={props.inputs}>
						{(input, i) => {
							const [ref, setRef] = createSignal<HTMLDivElement>();

							useIOPositionTrack(i, input.id, "i", ref);

							const [draggingPointers, setDraggingPointers] =
								createSignal<number[]>();

							return (
								<div class="flex flex-row items-center space-x-1.5 h-4.5">
									<div
										ref={setRef}
										class={cx(
											"relative size-3.5 border-[2.5px] rounded-full border-current @hover-bg-current",
											input.variant === "data" && matchTypeColor(input.data),
											((draggingPointers()?.length ?? 0) > 0 ||
												props.connections?.in?.includes(input.id)) &&
												"bg-current",
										)}
									>
										<div
											class={cx(
												"absolute",
												isTouchDevice ? "-inset-2" : "inset-0",
											)}
											onPointerDown={(e) => {
												if (
													onPinPointerDown(e, input.id, "i", () =>
														setDraggingPointers((s) =>
															s?.filter((p) => p !== e.pointerId),
														),
													)
												) {
													setDraggingPointers((s) =>
														s ? [...s, e.pointerId] : [e.pointerId],
													);
												}
											}}
											onPointerUp={(e) =>
												props.onPinPointerUp?.(e, "i", input.id)
											}
											onDblClick={() => props.onPinDoubleClick?.("i", input.id)}
										/>
									</div>
									<span>{input.name ?? input.id}</span>
								</div>
							);
						}}
					</For>
				</div>
				<div class="flex-1" />
				<div class="px-1.5 py-2 flex flex-col gap-2.5 items-end">
					<For each={props.outputs}>
						{(output, i) => {
							const [ref, setRef] = createSignal<HTMLDivElement>();

							useIOPositionTrack(i, output.id, "o", ref);

							const [draggingPointers, setDraggingPointers] =
								createSignal<number[]>();

							return (
								<div class="flex flex-row items-center space-x-1.5 h-4.5">
									<span>{output.name ?? output.id}</span>
									<div
										ref={setRef}
										class={cx(
											"relative size-3.5 border-[2.5px] rounded-full border-current @hover-bg-current",
											output.variant === "data" && matchTypeColor(output.data),
											((draggingPointers()?.length ?? 0) > 0 ||
												props.connections?.out?.includes(output.id)) &&
												"bg-current",
										)}
									>
										<div
											class={cx(
												"absolute",
												isTouchDevice ? "-inset-2" : "inset-0",
											)}
											onPointerDown={(e) => {
												if (
													onPinPointerDown(e, output.id, "o", () =>
														setDraggingPointers((s) =>
															s?.filter((p) => p !== e.pointerId),
														),
													)
												) {
													setDraggingPointers((s) =>
														s ? [...s, e.pointerId] : [e.pointerId],
													);
												}
											}}
											onPointerUp={(e) =>
												props.onPinPointerUp?.(e, "o", output.id)
											}
											onDblClick={() =>
												props.onPinDoubleClick?.("o", output.id)
											}
										/>
									</div>
								</div>
							);
						}}
					</For>
				</div>
			</div>
		</div>
	);
}

export function NodeHeader(
	props: { variant: NodeVariant; name: string } & ComponentProps<"div">,
) {
	return (
		<div class={cx("h-5.5 font-medium", matchNodeVariantColor(props.variant))}>
			<div
				{...props}
				class={cx(
					"px-1.75 h-full text-left bg-transparent w-full flex flex-row items-center",
					props.class,
				)}
			>
				{props.name}
			</div>
		</div>
	);
}

const matchNodeVariantColor = Match.type<NodeVariant>().pipe(
	Match.when("base", () => "bg-neutral-600"),
	Match.when("event", () => "bg-red-700"),
	Match.when("exec", () => "bg-blue-600"),
	Match.when("pure", () => "bg-emerald-700"),
	Match.exhaustive,
);

const matchTypeColor = Match.type<DataType>().pipe(
	Match.when("bool", () => "text-red-600"),
	Match.when("float", () => "text-green-600"),
	Match.when("int", () => "text-teal-300"),
	Match.when("string", () => "text-pink-500"),
	Match.exhaustive,
);



---
File: /packages/server-frontend/src/Realtime.ts
---

import { createContext, useContext } from "solid-js";

const RealtimeContext = createContext<{
	id: () => number;
}>();

export const RealtimeContextProvider = RealtimeContext.Provider;

export function useRealtimeContext() {
	const ctx = useContext(RealtimeContext);
	if (!ctx)
		throw new Error(
			"useRealtimeContext must be used within a RealtimeContextProvider",
		);

	return ctx;
}



---
File: /packages/server-frontend/src/style.css
---

@import "@radix-ui/colors/gray.css";
@import "@radix-ui/colors/gray-dark.css";
@import "@radix-ui/colors/red.css";
@import "@radix-ui/colors/red-dark.css";

html {
  user-select: none;
}

button:hover {
  cursor: default;
}

a:hover {
  cursor: default;
}

a:hover[rel="external"] {
  cursor: inherit;
}



---
File: /packages/server-frontend/src/utils.ts
---

import { Node } from "@macrograph/server-domain";

export type IORef = `${Node.Id}:${"i" | "o"}:${string}`;

export function parseIORef(ioRef: IORef) {
	const [nodeId, type, ...id] = ioRef.split(":");
	return {
		nodeId: Node.Id.make(Number(nodeId)),
		type: type as "i" | "o",
		id: id.join(""),
	};
}

import { isMobile } from "@solid-primitives/platform";

export const isTouchDevice = isMobile || navigator.maxTouchPoints > 0;



---
File: /packages/server-frontend/package.json
---

{
	"name": "@macrograph/server-frontend",
	"main": "./src/index.tsx",
	"types": "./src/index.tsx",
	"devDependencies": {
		"@effect/language-service": "^0.20.0",
		"@effect/vitest": "^0.20.2",
		"@iconify-json/gg": "^1.0.0",
		"@iconify-json/line-md": "^1.2.8",
		"@iconify-json/lucide": "^1.2.32",
		"@iconify-json/material-symbols": "^1.2.23",
		"@iconify-json/svg-spinners": "^1.2.2",
		"typescript": "~5.7.2",
		"unocss": "^66.1.1",
		"unocss-preset-animations": "^1.2.1",
		"unplugin-auto-import": "^19.3.0",
		"unplugin-icons": "^0.18.5",
		"vite": "^6.3.5"
	},
	"dependencies": {
		"@effect/experimental": "^0.46.1",
		"@effect/opentelemetry": "^0.50.3",
		"@effect/platform": "^0.80.2",
		"@effect/platform-browser": "^0.59.2",
		"@effect/platform-node": "^0.78.1",
		"@effect/rpc": "^0.62.4",
		"@effect/rpc-http": "^0.52.4",
		"@faker-js/faker": "^9.8.0",
		"@kobalte/core": "^0.13.7",
		"@macrograph/domain": "workspace:*",
		"@macrograph/web-api": "workspace:*",
		"@macrograph/package-sdk": "workspace:*",
		"@macrograph/server-domain": "workspace:*",
		"@opentelemetry/exporter-trace-otlp-http": "^0.201.1",
		"@opentelemetry/sdk-logs": "^0.201.1",
		"@opentelemetry/sdk-metrics": "^2.0.1",
		"@opentelemetry/sdk-trace-base": "^2.0.1",
		"@opentelemetry/sdk-trace-node": "^2.0.1",
		"@opentelemetry/sdk-trace-web": "^2.0.1",
		"@radix-ui/colors": "^3.0.0",
		"@solid-primitives/bounds": "^0.0.118",
		"@solid-primitives/context": "^0.2.3",
		"@solid-primitives/event-listener": "^2.3.3",
		"@solid-primitives/map": "^0.4.11",
		"@solid-primitives/mouse": "^2.0.19",
		"@solid-primitives/platform": "^0.1.2",
		"@solid-primitives/refs": "^1.0.8",
		"@solid-primitives/resource": "^0.1.2",
		"@solid-primitives/state-machine": "^0.0.3",
		"@solidjs/router": "^0.15.3",
		"@tanstack/query-core": "^5.75.7",
		"@unocss/reset": "^66.1.1",
		"cva": "npm:class-variance-authority@^0.7.1",
		"dotenv-cli": "^8.0.0",
		"effect": "^3.16.8",
		"hono": "^4.7.5",
		"jose": "^4.15.9",
		"obs-websocket-js": "^5.0.5",
		"solid-presence": "^0.2.0",
		"unocss-preset-primitives": "0.0.2-beta.1",
		"unocss-preset-radix": "^2.8.2",
		"vite-plugin-solid": "^2.10.2"
	}
}



---
File: /packages/server-frontend/tsconfig.json
---

{
	"compilerOptions": {
		"target": "ESNext",
		"useDefineForClassFields": true,
		"module": "ESNext",
		"lib": ["ES2021", "DOM", "DOM.Iterable"],
		"skipLibCheck": true,
		"jsx": "preserve",
		"jsxImportSource": "solid-js",

		/* Bundler mode */
		"moduleResolution": "bundler",
		"allowImportingTsExtensions": true,
		"isolatedModules": true,
		"moduleDetection": "force",
		"noEmit": true,

		/* Linting */
		"strict": true,
		// "noUnusedLocals": true,
		// "noUnusedParameters": true,
		"noUncheckedIndexedAccess": true,
		"noFallthroughCasesInSwitch": true,
		"types": ["unplugin-icons/types/solid"],
		"plugins": [{ "name": "@effect/language-service" }]
	},
	"include": ["src"]
}

